name: Release Pipeline

on:
  push:
    tags:
      - 'v*.*.*-beta.*'  # Beta releases: v1.0.0-beta.1, v1.0.0-beta.2, etc.
      - 'v*.*.*-test.*'  # Test builds: v1.0.0-test.1 (skips notarization, saves costs)
      # This ensures:
      # - Alpha tags (v*.*.*-alpha.*) don't trigger builds (checkpoints only)
      # - Production tags (v*.*.*) don't trigger builds (manual promotion only)
      # - Beta tags trigger full CI/CD with notarization
      # - Test tags trigger full CI/CD WITHOUT notarization (for testing)
  
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.0)'
        required: false
      promote_from:
        description: 'Beta version to promote (e.g., 1.0.0-beta.3) - leave empty for new build'
        required: false
      list_available_betas:
        description: 'List available beta releases for promotion (check this to see options)'
        type: boolean
        default: false
      prerelease:
        description: 'Mark as pre-release'
        type: boolean
        default: false
      release_only:
        description: 'Skip build and only create release from existing artifacts'
        required: false
        type: boolean
        default: false
      selective_build:
        description: 'Enable selective platform building (for testing)'
        type: boolean
        default: false
      build_macos_intel:
        description: 'Build macOS Intel (x86_64)'
        type: boolean
        default: true
      build_macos_arm:
        description: 'Build macOS ARM (Apple Silicon)'
        type: boolean
        default: true
      build_linux:
        description: 'Build Linux'
        type: boolean
        default: true
      build_windows:
        description: 'Build Windows'
        type: boolean
        default: true

jobs:
  # List available beta releases for promotion
  list-betas:
    if: github.event.inputs.list_available_betas == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: List Available Beta Releases
        run: |
          echo "## üìã Available Beta Releases for Promotion" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Version | Created | Status | Assets |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|---------|---------|---------|" >> $GITHUB_STEP_SUMMARY
          
          # List all beta releases (published and draft)
          gh release list \
            --repo ${{ github.repository }} \
            --limit 20 \
            --json tagName,name,createdAt,isDraft \
            --jq '.[] | select(.tagName | test("-beta")) | [.tagName, .createdAt[:10], (if .isDraft then "Draft" else "Published" end)] | @csv' \
          | while IFS=',' read -r tag date status; do
            # Clean up CSV formatting
            tag=$(echo "$tag" | tr -d '"')
            date=$(echo "$date" | tr -d '"')
            status=$(echo "$status" | tr -d '"')
            
            # Count assets for this release
            asset_count=$(gh release view "$tag" --repo ${{ github.repository }} --json assets --jq '.assets | length' 2>/dev/null || echo "0")
            
            echo "| \`$tag\` | $date | $status | $asset_count |" >> $GITHUB_STEP_SUMMARY
          done
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Usage:** Re-run this workflow with \`promote_from\` set to one of the beta versions above." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Example:** \`promote_from: 1.0.0-beta.3\` and \`version: 1.0.0\`" >> $GITHUB_STEP_SUMMARY
        env:
          GH_TOKEN: ${{ github.token }}

  # Handle promotion workflow when promote_from is specified
  promote:
    if: github.event.inputs.promote_from != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      
      - name: Promote Release
        uses: ./.github/actions/promote-release
        with:
          source-version: ${{ github.event.inputs.promote_from }}
          target-version: ${{ github.event.inputs.version }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          draft: true
      
      - name: Summary
        run: |
          echo "## üéâ Release Promoted Successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **From**: v${{ github.event.inputs.promote_from }}" >> $GITHUB_STEP_SUMMARY
          echo "- **To**: v${{ github.event.inputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: Draft (ready for manual publish)" >> $GITHUB_STEP_SUMMARY

  # Main build and release workflow
  publish-tauri:
    # Skip if we're promoting or only creating a release
    if: github.event.inputs.promote_from == '' && inputs.release_only != true
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          # macOS Intel
          - platform: 'macos-latest'
            args: '--target x86_64-apple-darwin'
            arch: 'intel'
            label: 'macOS (Intel)'
            platform_id: 'macos_intel'
          
          # macOS Apple Silicon
          - platform: 'macos-latest'
            args: '--target aarch64-apple-darwin'
            arch: 'apple-silicon'
            label: 'macOS (Apple M-series)'
            platform_id: 'macos_arm'
          
          # Linux x64 - Standard Linux desktops (.deb, .rpm, .appimage, .tar.gz)
          - platform: 'ubuntu-22.04'
            args: '--target x86_64-unknown-linux-gnu'
            arch: 'x64'
            label: 'Linux'
            platform_id: 'linux'
          
          # Windows x64
          - platform: 'windows-latest'
            args: '--target x86_64-pc-windows-msvc'
            arch: 'x64'
            label: 'Windows'
            platform_id: 'windows'

    runs-on: ${{ matrix.platform }}
    
    steps:
      # Check if this platform should be built based on selective build settings
      - name: Check Platform Build Condition
        id: should_build
        run: |
          # For tag pushes, build all platforms (beta and test tags)
          if [[ "${{ github.event_name }}" == "push" ]]; then
            TAG="${GITHUB_REF#refs/tags/}"
            echo "üè∑Ô∏è Processing tag: $TAG"
            echo "build=true" >> $GITHUB_OUTPUT

            if [[ "$TAG" == *"-beta."* ]]; then
              echo "‚úÖ Building (beta release - all platforms with notarization)"
            elif [[ "$TAG" == *"-test."* ]]; then
              echo "‚úÖ Building (test release - all platforms, skipping notarization)"
            else
              echo "‚úÖ Building (production tag - all platforms)"
            fi
          # For workflow_dispatch, check selective build settings
          elif [[ "${{ inputs.selective_build }}" != "true" ]]; then
            echo "build=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Building (selective build disabled - all platforms)"
          else
            # Selective build is enabled, check individual platform settings
            case "${{ matrix.platform_id }}" in
              macos_intel)
                if [[ "${{ inputs.build_macos_intel }}" == "true" ]]; then
                  echo "build=true" >> $GITHUB_OUTPUT
                  echo "‚úÖ Building macOS Intel (selected)"
                else
                  echo "build=false" >> $GITHUB_OUTPUT
                  echo "‚è≠Ô∏è Skipping macOS Intel (not selected)"
                fi
                ;;
              macos_arm)
                if [[ "${{ inputs.build_macos_arm }}" == "true" ]]; then
                  echo "build=true" >> $GITHUB_OUTPUT
                  echo "‚úÖ Building macOS ARM (selected)"
                else
                  echo "build=false" >> $GITHUB_OUTPUT
                  echo "‚è≠Ô∏è Skipping macOS ARM (not selected)"
                fi
                ;;
              linux_x64|linux_arm64)
                if [[ "${{ inputs.build_linux }}" == "true" ]]; then
                  echo "build=true" >> $GITHUB_OUTPUT
                  echo "‚úÖ Building Linux ${{ matrix.arch }} (selected)"
                else
                  echo "build=false" >> $GITHUB_OUTPUT
                  echo "‚è≠Ô∏è Skipping Linux ${{ matrix.arch }} (not selected)"
                fi
                ;;
              windows)
                if [[ "${{ inputs.build_windows }}" == "true" ]]; then
                  echo "build=true" >> $GITHUB_OUTPUT
                  echo "‚úÖ Building Windows (selected)"
                else
                  echo "build=false" >> $GITHUB_OUTPUT
                  echo "‚è≠Ô∏è Skipping Windows (not selected)"
                fi
                ;;
            esac
          fi
        shell: bash
      
      # Skip this job if platform is not selected
      - name: Skip Job if Platform Not Selected
        if: steps.should_build.outputs.build == 'false'
        run: |
          echo "Platform not selected for build, exiting successfully"
          exit 0
        shell: bash
      
      - uses: actions/checkout@v4
        if: steps.should_build.outputs.build == 'true'
      
      # Setup Apple certificate for macOS signing
      - name: Setup Apple Certificate
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        uses: ./.github/actions/apple-certificates
        with:
          certificate-p12: ${{ secrets.APPLE_CERTIFICATE_P12 }}
          certificate-password: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          operation: setup
      
      - name: Setup Node
        if: steps.should_build.outputs.build == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: 'npm'
      
      - name: Install Rust stable
        if: steps.should_build.outputs.build == 'true'
        uses: dtolnay/rust-toolchain@87f07835889b686aca1fb3733c2aa2d61586c1e1
        with:
          toolchain: stable
          targets: ${{ matrix.arch == 'intel' && 'x86_64-apple-darwin' || matrix.arch == 'apple-silicon' && 'aarch64-apple-darwin' || matrix.arch == 'x64' && contains(matrix.platform, 'ubuntu') && 'x86_64-unknown-linux-gnu' || matrix.arch == 'arm64' && contains(matrix.platform, 'ubuntu') && 'aarch64-unknown-linux-gnu' || matrix.platform == 'windows-latest' && 'x86_64-pc-windows-msvc' }}
      
      - name: Rust cache
        if: steps.should_build.outputs.build == 'true'
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Run sccache
        if: steps.should_build.outputs.build == 'true'
        uses: mozilla-actions/sccache-action@v0.0.7

      - name: Install dependencies (Ubuntu only)
        if: contains(matrix.platform, 'ubuntu') && steps.should_build.outputs.build == 'true'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libayatana-appindicator3-dev librsvg2-dev patchelf xdg-utils
          sudo apt-get install -y libwebkit2gtk-4.0-dev || true
          sudo apt-get install -y rpm
          sudo apt-get install -y libpcsclite-dev swig
      
      - name: Install frontend dependencies
        if: steps.should_build.outputs.build == 'true'
        run: npm install --prefix src-ui

      # Binary dependencies - fetch from GitHub Release
      - name: Cache Binary Dependencies
        if: steps.should_build.outputs.build == 'true'
        uses: actions/cache@v4
        with:
          path: src-tauri/bin/
          key: binaries-${{ runner.os }}-${{ matrix.platform_id }}-${{ hashFiles('src-tauri/bin/binary-dependencies.json') }}
          restore-keys: |
            binaries-${{ runner.os }}-${{ matrix.platform_id }}-
            binaries-${{ runner.os }}-

      - name: Fetch Binary Dependencies
        if: steps.should_build.outputs.build == 'true'
        run: |
          chmod +x scripts/cicd/fetch-binaries.sh
          ./scripts/cicd/fetch-binaries.sh
        shell: bash

      - name: Verify Binary Dependencies
        if: steps.should_build.outputs.build == 'true'
        run: |
          # Verify binaries were downloaded
          echo "Verifying binaries for ${{ matrix.platform }}..."

          if [[ "${{ matrix.platform }}" == "macos-latest" ]]; then
            PLATFORM_DIR="darwin"
          elif [[ "${{ matrix.platform }}" == *"ubuntu"* ]]; then
            PLATFORM_DIR="linux"
          else
            PLATFORM_DIR="windows"
          fi

          # Check required binaries exist
          for binary in age age-plugin-yubikey ykman; do
            if [ ! -e "src-tauri/bin/$PLATFORM_DIR/$binary" ] && [ ! -e "src-tauri/bin/$PLATFORM_DIR/${binary}.bat" ]; then
              echo "‚ùå ERROR: Binary not found: $binary"
              exit 1
            fi
          done

          # Check ykman-bundle exists
          if [ ! -d "src-tauri/bin/$PLATFORM_DIR/ykman-bundle" ]; then
            echo "‚ùå ERROR: ykman-bundle directory not found"
            exit 1
          fi

          echo "‚úÖ All binaries verified for $PLATFORM_DIR"
        shell: bash

      - name: Build with Tauri
        if: steps.should_build.outputs.build == 'true'
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_DEVELOPER_ID }}
          SCCACHE_GHA_ENABLED: "true"
          RUSTC_WRAPPER: "sccache"
        with:
          args: ${{ matrix.args }}

      # Verify binaries in bundled artifacts (Post-Bundle Verification)
      - name: Verify Binaries in Bundled Artifacts
        if: steps.should_build.outputs.build == 'true'
        shell: bash
        run: |
          echo "üîç Verifying binaries in bundled artifacts..."

          if [[ "${{ matrix.platform }}" == "macos-latest" ]]; then
            # macOS: Find and mount DMG
            DMG=$(find target/*/release/bundle/dmg -name "*.dmg" | head -1)
            echo "Found DMG: $DMG"

            # Mount the DMG
            hdiutil attach "$DMG" -quiet
            MOUNT_POINT=$(df | grep "Barqly Vault" | awk '{print $NF}')

            # Verify binaries exist in app bundle
            APP="$MOUNT_POINT/Barqly Vault.app"
            echo "Checking binaries in: $APP/Contents/Resources/bin/darwin/"

            test -f "$APP/Contents/Resources/bin/darwin/age" || { echo "‚ùå age missing"; exit 1; }
            test -f "$APP/Contents/Resources/bin/darwin/age-plugin-yubikey" || { echo "‚ùå age-plugin-yubikey missing"; exit 1; }
            test -f "$APP/Contents/Resources/bin/darwin/ykman" || { echo "‚ùå ykman wrapper missing"; exit 1; }
            test -d "$APP/Contents/Resources/bin/darwin/ykman-bundle" || { echo "‚ùå ykman-bundle missing"; exit 1; }
            test -f "$APP/Contents/Resources/bin/darwin/ykman-bundle/ykman" || { echo "‚ùå ykman binary missing"; exit 1; }

            # Unmount
            hdiutil detach "$MOUNT_POINT" -quiet
            echo "‚úÖ macOS binaries verified in DMG"

          elif [[ "${{ matrix.platform }}" == *"ubuntu"* ]]; then
            # Linux: Extract and verify AppImage
            APPIMAGE=$(find target/*/release/bundle/appimage -name "*.AppImage" | head -1)
            echo "Found AppImage: $APPIMAGE"

            # Make it executable and extract
            chmod +x "$APPIMAGE"
            "$APPIMAGE" --appimage-extract > /dev/null 2>&1

            # Use find to locate binaries (Tauri puts them under resources/bin)
            echo "Searching for binaries in extracted AppImage..."

            # Look for age binary under resources/bin/linux
            AGE_PATH=$(find squashfs-root -path "*/resources/bin/linux/age" | head -1)
            test -n "$AGE_PATH" || { echo "‚ùå age not found in AppImage"; exit 1; }
            echo "‚úì Found age at: $AGE_PATH"

            # Look for age-plugin-yubikey
            PLUGIN_PATH=$(find squashfs-root -path "*/resources/bin/linux/age-plugin-yubikey" | head -1)
            test -n "$PLUGIN_PATH" || { echo "‚ùå age-plugin-yubikey not found in AppImage"; exit 1; }
            echo "‚úì Found age-plugin-yubikey at: $PLUGIN_PATH"

            # Look for ykman wrapper
            YKMAN_PATH=$(find squashfs-root -path "*/resources/bin/linux/ykman" | head -1)
            test -n "$YKMAN_PATH" || { echo "‚ùå ykman not found in AppImage"; exit 1; }
            echo "‚úì Found ykman at: $YKMAN_PATH"

            # Look for ykman-bundle directory
            BUNDLE_PATH=$(find squashfs-root -path "*/resources/bin/linux/ykman-bundle" -type d | head -1)
            test -n "$BUNDLE_PATH" || { echo "‚ùå ykman-bundle not found in AppImage"; exit 1; }
            echo "‚úì Found ykman-bundle at: $BUNDLE_PATH"

            # Verify ykman binary inside bundle
            test -f "$BUNDLE_PATH/ykman" || { echo "‚ùå ykman binary missing from bundle"; exit 1; }

            # Clean up
            rm -rf squashfs-root
            echo "‚úÖ Linux binaries verified in AppImage"

          elif [[ "${{ matrix.platform }}" == "windows-latest" ]]; then
            # Windows: Check MSI contents (requires msitools or 7zip)
            MSI=$(find target/*/release/bundle/msi -name "*.msi" | head -1)
            echo "Found MSI: $MSI"

            # We can't easily extract MSI on GitHub Actions Windows runners without tools
            # So we'll check the staging directory as a proxy (not ideal but better than nothing)
            echo "Checking Windows staging directory for verification..."

            # Check that files exist with .exe extensions
            test -f "src-tauri/bin/windows/age.exe" || { echo "‚ùå age.exe missing"; exit 1; }
            test -f "src-tauri/bin/windows/age-plugin-yubikey.exe" || { echo "‚ùå age-plugin-yubikey.exe missing"; exit 1; }
            test -f "src-tauri/bin/windows/ykman.bat" || { echo "‚ùå ykman.bat missing"; exit 1; }
            test -d "src-tauri/bin/windows/ykman-bundle" || { echo "‚ùå ykman-bundle missing"; exit 1; }
            test -f "src-tauri/bin/windows/ykman-bundle/ykman.exe" || { echo "‚ùå ykman.exe missing from bundle"; exit 1; }

            echo "‚úÖ Windows binaries verified (staging check)"
            echo "‚ö†Ô∏è  Note: Full MSI extraction would require additional tools"
          fi

          echo "‚úÖ Post-bundle verification complete for ${{ matrix.platform }}"

      # Find and notarize macOS DMG
      - name: Find DMG Path
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        id: find-dmg
        run: |
          if [ "${{ matrix.arch }}" = "intel" ]; then
            DMG_DIR="${{ github.workspace }}/target/x86_64-apple-darwin/release/bundle/dmg"
          else
            DMG_DIR="${{ github.workspace }}/target/aarch64-apple-darwin/release/bundle/dmg"
          fi
          DMG_PATH=$(find "$DMG_DIR" -name "*.dmg" -type f | head -1)
          echo "dmg-path=$DMG_PATH" >> $GITHUB_OUTPUT
        shell: bash
      
      - name: Notarize macOS DMG
        if: |
          matrix.platform == 'macos-latest' &&
          steps.should_build.outputs.build == 'true' &&
          !contains(github.ref, '-test.')
        uses: ./.github/actions/notarize-macos
        with:
          dmg-path: ${{ steps.find-dmg.outputs.dmg-path }}
          api-key: ${{ secrets.APPLE_API_KEY }}
          api-key-id: ${{ secrets.APPLE_API_KEY_ID }}
          api-issuer-id: ${{ secrets.APPLE_API_ISSUER_ID }}
      
      # Extract version from tag or input
      - name: Extract Version
        if: steps.should_build.outputs.build == 'true'
        id: version
        run: |
          if [[ "$GITHUB_REF" =~ refs/tags/v?(.+) ]]; then
            VERSION="${BASH_REMATCH[1]}"
          elif [[ -n "${{ github.event.inputs.version }}" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="dev"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
        shell: bash
      
      # Rename artifacts with consistent naming
      - name: Rename Artifacts
        if: steps.should_build.outputs.build == 'true'
        uses: ./.github/actions/rename-artifacts
        with:
          platform: ${{ matrix.platform }}
          arch: ${{ matrix.arch }}
          version: ${{ steps.version.outputs.version }}
      
      # Upload renamed artifacts
      - name: Upload artifacts
        if: steps.should_build.outputs.build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: barqly-vault-${{ matrix.platform }}-${{ matrix.arch }}
          path: renamed-artifacts/*
          retention-days: 7
      
      # Cleanup Apple keychain
      - name: Cleanup Apple Keychain
        if: always() && matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        uses: ./.github/actions/apple-certificates
        with:
          operation: cleanup

  # Create beta release with all artifacts
  create-beta-release:
    name: Create Beta Release
    needs: [publish-tauri]
    if: |
      always() && 
      github.event.inputs.promote_from == '' &&
      (needs.publish-tauri.result == 'success' || inputs.release_only == true) &&
      (startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Extract version
        id: get_version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION=${GITHUB_REF#refs/tags/v}
          fi
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "üì¶ Creating release for version: $VERSION"
      
      # Download all artifacts from build job
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        if: inputs.release_only != true
        with:
          path: release-artifacts
      
      # Download artifacts from previous run when release_only
      - name: Download artifacts from previous run
        if: inputs.release_only == true
        run: |
          echo "üîç Finding the most recent successful build for v${{ steps.get_version.outputs.VERSION }}..."
          
          RUN_ID=$(gh run list \
            --workflow=release.yml \
            --branch="v${{ steps.get_version.outputs.VERSION }}" \
            --status=completed \
            --limit=10 \
            --json databaseId,conclusion \
            --jq '.[] | select(.conclusion == "success" or .conclusion == "failure") | .databaseId' | head -1)
          
          if [ -z "$RUN_ID" ]; then
            echo "‚ùå No previous runs found for v${{ steps.get_version.outputs.VERSION }}"
            exit 1
          fi
          
          echo "üì• Downloading artifacts from run $RUN_ID..."
          mkdir -p release-artifacts
          gh run download $RUN_ID --dir release-artifacts
          echo "‚úÖ Downloaded artifacts from run $RUN_ID"
        env:
          GH_TOKEN: ${{ github.token }}
      
      - name: Prepare release assets
        run: |
          mkdir -p release-assets
          
          # Move all artifacts to release-assets, flattening structure
          find release-artifacts -type f \( \
            -name "*.dmg" -o \
            -name "*.exe" -o \
            -name "*.msi" -o \
            -name "*.deb" -o \
            -name "*.rpm" -o \
            -name "*.AppImage" -o \
            -name "*.tar.gz" -o \
            -name "*.zip" \
          \) -exec cp {} release-assets/ \;
          
          echo "üì¶ Final release assets:"
          ls -la release-assets/
      
      - name: Generate checksums
        uses: ./.github/actions/create-checksums
        with:
          artifacts-dir: release-assets
      
      # Clean up any existing release
      - name: Delete existing release if present
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          
          if gh release view "v$VERSION" &>/dev/null; then
            echo "‚ö†Ô∏è Found existing release for v$VERSION, deleting it..."
            gh release delete "v$VERSION" --yes
            echo "‚úÖ Existing release deleted"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Generate release notes
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          ./scripts/cicd/generate-release-notes.sh "$VERSION" > release-notes.md
      
      - name: Create draft release
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          
          gh release create "v$VERSION" \
            --draft \
            --title "Barqly Vault v$VERSION" \
            --notes-file release-notes.md \
            release-assets/*
          
          echo "‚úÖ Beta release created for v$VERSION"
          echo "üìù Review and publish at: https://github.com/${{ github.repository }}/releases"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Automatically create production release draft when beta is created
  create-production-release:
    name: Create Production Release
    needs: [create-beta-release]
    if: |
      needs.create-beta-release.result == 'success' && 
      contains(github.ref, '-beta')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Extract version and create production version
        id: get_version
        run: |
          # Get the beta version from tag
          BETA_VERSION=${GITHUB_REF#refs/tags/v}
          echo "BETA_VERSION=$BETA_VERSION" >> $GITHUB_OUTPUT
          
          # Extract production version from beta.N format (e.g., 1.0.0-beta.3 -> 1.0.0)
          if [[ "$BETA_VERSION" =~ ^([0-9]+\.[0-9]+\.[0-9]+)-beta\.[0-9]+$ ]]; then
            PROD_VERSION="${BASH_REMATCH[1]}"
          else
            echo "‚ùå ERROR: Invalid beta version format. Expected format: X.Y.Z-beta.N"
            exit 1
          fi
          echo "PROD_VERSION=$PROD_VERSION" >> $GITHUB_OUTPUT
          
          echo "üì¶ Creating production release draft for v$PROD_VERSION from beta v$BETA_VERSION"
      
      - name: Download beta release assets
        run: |
          # Download all assets from the beta release
          mkdir -p production-assets
          
          gh release download "v${{ steps.get_version.outputs.BETA_VERSION }}" \
            --dir production-assets \
            --repo ${{ github.repository }}
          
          echo "üì• Downloaded beta assets:"
          ls -la production-assets/
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Rename artifacts for production
        run: |
          cd production-assets
          
          BETA_VERSION="${{ steps.get_version.outputs.BETA_VERSION }}"
          PROD_VERSION="${{ steps.get_version.outputs.PROD_VERSION }}"
          
          echo "üìù Renaming artifacts from $BETA_VERSION to $PROD_VERSION..."
          
          # Rename all files that contain the beta version string
          for file in *; do
            if [[ "$file" == *"$BETA_VERSION"* ]]; then
              new_name="${file//$BETA_VERSION/$PROD_VERSION}"
              mv "$file" "$new_name"
              echo "  Renamed: $file ‚Üí $new_name"
            fi
          done
          
          # Regenerate checksums with new filenames
          if [ -f "checksums.txt" ]; then
            echo "üìù Regenerating checksums..."
            rm checksums.txt
            shasum -a 256 * > checksums.txt
            echo "‚úÖ Checksums regenerated"
          fi
          
          echo "üì¶ Final production artifacts:"
          ls -la
      
      - name: Create production tag
        run: |
          # Configure git identity for tagging
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "GitHub Actions"
          
          # Delete existing tag if it exists (from previous failed runs)
          git push origin --delete "v${{ steps.get_version.outputs.PROD_VERSION }}" 2>/dev/null || true
          
          # Create a production tag pointing to the same commit as beta
          git tag "v${{ steps.get_version.outputs.PROD_VERSION }}" -m "Production release from v${{ steps.get_version.outputs.BETA_VERSION }}"
          git push origin "v${{ steps.get_version.outputs.PROD_VERSION }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Generate production release notes
        run: |
          PROD_VERSION="${{ steps.get_version.outputs.PROD_VERSION }}"
          ./scripts/cicd/generate-release-notes.sh "$PROD_VERSION" > release-notes.md
      
      - name: Create production draft release
        run: |
          PROD_VERSION="${{ steps.get_version.outputs.PROD_VERSION }}"
          
          gh release create "v$PROD_VERSION" \
            --draft \
            --title "Barqly Vault v$PROD_VERSION" \
            --notes-file release-notes.md \
            production-assets/*
          
          echo "‚úÖ Production draft release created for v$PROD_VERSION"
          echo "üìù Ready to publish at: https://github.com/${{ github.repository }}/releases"
          echo ""
          echo "‚ö†Ô∏è This is a DRAFT - manually publish when ready for production!"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

