name: Release Pipeline

on:
  push:
    tags:
      - 'v*.*.*-beta.*'  # Beta releases: v1.0.0-beta.1, v1.0.0-beta.2, etc.
      - 'v*.*.*-test.*'  # Test builds: v1.0.0-test.1 (skips notarization, saves costs)
      # This ensures:
      # - Alpha tags (v*.*.*-alpha.*) don't trigger builds (checkpoints only)
      # - Production tags (v*.*.*) don't trigger builds (manual promotion only)
      # - Beta tags trigger full CI/CD with notarization
      # - Test tags trigger full CI/CD WITHOUT notarization (for testing)
  
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.0)'
        required: false
      promote_from:
        description: 'Beta version to promote (e.g., 1.0.0-beta.3) - leave empty for new build'
        required: false
      list_available_betas:
        description: 'List available beta releases for promotion (check this to see options)'
        type: boolean
        default: false
      prerelease:
        description: 'Mark as pre-release'
        type: boolean
        default: false
      release_only:
        description: 'Skip build and only create release from existing artifacts'
        required: false
        type: boolean
        default: false
      selective_build:
        description: 'Enable selective platform building (for testing)'
        type: boolean
        default: false
      build_macos_intel:
        description: 'Build macOS Intel (x86_64)'
        type: boolean
        default: true
      build_macos_arm:
        description: 'Build macOS ARM (Apple Silicon)'
        type: boolean
        default: true
      build_linux:
        description: 'Build Linux'
        type: boolean
        default: true
      build_windows:
        description: 'Build Windows'
        type: boolean
        default: true

jobs:
  # List available beta releases for promotion
  list-betas:
    if: github.event.inputs.list_available_betas == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: List Available Beta Releases
        run: |
          echo "## üìã Available Beta Releases for Promotion" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Version | Created | Status | Assets |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|---------|---------|---------|" >> $GITHUB_STEP_SUMMARY
          
          # List all beta releases (published and draft)
          gh release list \
            --repo ${{ github.repository }} \
            --limit 20 \
            --json tagName,name,createdAt,isDraft \
            --jq '.[] | select(.tagName | test("-beta")) | [.tagName, .createdAt[:10], (if .isDraft then "Draft" else "Published" end)] | @csv' \
          | while IFS=',' read -r tag date status; do
            # Clean up CSV formatting
            tag=$(echo "$tag" | tr -d '"')
            date=$(echo "$date" | tr -d '"')
            status=$(echo "$status" | tr -d '"')
            
            # Count assets for this release
            asset_count=$(gh release view "$tag" --repo ${{ github.repository }} --json assets --jq '.assets | length' 2>/dev/null || echo "0")
            
            echo "| \`$tag\` | $date | $status | $asset_count |" >> $GITHUB_STEP_SUMMARY
          done
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Usage:** Re-run this workflow with \`promote_from\` set to one of the beta versions above." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Example:** \`promote_from: 1.0.0-beta.3\` and \`version: 1.0.0\`" >> $GITHUB_STEP_SUMMARY
        env:
          GH_TOKEN: ${{ github.token }}

  # Handle promotion workflow when promote_from is specified
  promote:
    if: github.event.inputs.promote_from != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      
      - name: Promote Release
        uses: ./.github/actions/promote-release
        with:
          source-version: ${{ github.event.inputs.promote_from }}
          target-version: ${{ github.event.inputs.version }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          draft: true
      
      - name: Summary
        run: |
          echo "## üéâ Release Promoted Successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **From**: v${{ github.event.inputs.promote_from }}" >> $GITHUB_STEP_SUMMARY
          echo "- **To**: v${{ github.event.inputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: Draft (ready for manual publish)" >> $GITHUB_STEP_SUMMARY

  # Main build and release workflow
  publish-tauri:
    # Skip if we're promoting or only creating a release
    if: github.event.inputs.promote_from == '' && inputs.release_only != true
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          # macOS Intel
          - platform: 'macos-latest'
            args: '--target x86_64-apple-darwin'
            arch: 'intel'
            label: 'macOS (Intel)'
            platform_id: 'macos_intel'
          
          # macOS Apple Silicon
          - platform: 'macos-latest'
            args: '--target aarch64-apple-darwin'
            arch: 'apple-silicon'
            label: 'macOS (Apple M-series)'
            platform_id: 'macos_arm'
          
          # Linux x64 - Standard Linux desktops (.deb, .rpm, .appimage, .tar.gz)
          - platform: 'ubuntu-22.04'
            args: '--target x86_64-unknown-linux-gnu'
            arch: 'x64'
            label: 'Linux'
            platform_id: 'linux'
          
          # Windows x64
          - platform: 'windows-latest'
            args: '--target x86_64-pc-windows-msvc'
            arch: 'x64'
            label: 'Windows'
            platform_id: 'windows'

    runs-on: ${{ matrix.platform }}
    
    steps:
      # Check if this platform should be built based on selective build settings
      - name: Check Platform Build Condition
        id: should_build
        run: |
          # For tag pushes, build all platforms (beta and test tags)
          if [[ "${{ github.event_name }}" == "push" ]]; then
            TAG="${GITHUB_REF#refs/tags/}"
            echo "üè∑Ô∏è Processing tag: $TAG"
            echo "build=true" >> $GITHUB_OUTPUT

            if [[ "$TAG" == *"-beta."* ]]; then
              echo "‚úÖ Building (beta release - all platforms with notarization)"
            elif [[ "$TAG" == *"-test."* ]]; then
              echo "‚úÖ Building (test release - all platforms, skipping notarization)"
            else
              echo "‚úÖ Building (production tag - all platforms)"
            fi
          # For workflow_dispatch, check selective build settings
          elif [[ "${{ inputs.selective_build }}" != "true" ]]; then
            echo "build=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Building (selective build disabled - all platforms)"
          else
            # Selective build is enabled, check individual platform settings
            case "${{ matrix.platform_id }}" in
              macos_intel)
                if [[ "${{ inputs.build_macos_intel }}" == "true" ]]; then
                  echo "build=true" >> $GITHUB_OUTPUT
                  echo "‚úÖ Building macOS Intel (selected)"
                else
                  echo "build=false" >> $GITHUB_OUTPUT
                  echo "‚è≠Ô∏è Skipping macOS Intel (not selected)"
                fi
                ;;
              macos_arm)
                if [[ "${{ inputs.build_macos_arm }}" == "true" ]]; then
                  echo "build=true" >> $GITHUB_OUTPUT
                  echo "‚úÖ Building macOS ARM (selected)"
                else
                  echo "build=false" >> $GITHUB_OUTPUT
                  echo "‚è≠Ô∏è Skipping macOS ARM (not selected)"
                fi
                ;;
              linux_x64|linux_arm64)
                if [[ "${{ inputs.build_linux }}" == "true" ]]; then
                  echo "build=true" >> $GITHUB_OUTPUT
                  echo "‚úÖ Building Linux ${{ matrix.arch }} (selected)"
                else
                  echo "build=false" >> $GITHUB_OUTPUT
                  echo "‚è≠Ô∏è Skipping Linux ${{ matrix.arch }} (not selected)"
                fi
                ;;
              windows)
                if [[ "${{ inputs.build_windows }}" == "true" ]]; then
                  echo "build=true" >> $GITHUB_OUTPUT
                  echo "‚úÖ Building Windows (selected)"
                else
                  echo "build=false" >> $GITHUB_OUTPUT
                  echo "‚è≠Ô∏è Skipping Windows (not selected)"
                fi
                ;;
            esac
          fi
        shell: bash
      
      # Skip this job if platform is not selected
      - name: Skip Job if Platform Not Selected
        if: steps.should_build.outputs.build == 'false'
        run: |
          echo "Platform not selected for build, exiting successfully"
          exit 0
        shell: bash
      
      - uses: actions/checkout@v4
        if: steps.should_build.outputs.build == 'true'
      
      # Setup Apple certificate for macOS signing
      - name: Setup Apple Certificate
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        uses: ./.github/actions/apple-certificates
        with:
          certificate-p12: ${{ secrets.APPLE_CERTIFICATE_P12 }}
          certificate-password: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          operation: setup
      
      - name: Setup Node
        if: steps.should_build.outputs.build == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: 'npm'
      
      - name: Install Rust stable
        if: steps.should_build.outputs.build == 'true'
        uses: dtolnay/rust-toolchain@87f07835889b686aca1fb3733c2aa2d61586c1e1
        with:
          toolchain: stable
          targets: ${{ matrix.arch == 'intel' && 'x86_64-apple-darwin' || matrix.arch == 'apple-silicon' && 'aarch64-apple-darwin' || matrix.arch == 'x64' && contains(matrix.platform, 'ubuntu') && 'x86_64-unknown-linux-gnu' || matrix.arch == 'arm64' && contains(matrix.platform, 'ubuntu') && 'aarch64-unknown-linux-gnu' || matrix.platform == 'windows-latest' && 'x86_64-pc-windows-msvc' }}
      
      - name: Rust cache
        if: steps.should_build.outputs.build == 'true'
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Run sccache
        if: steps.should_build.outputs.build == 'true'
        uses: mozilla-actions/sccache-action@v0.0.7

      - name: Install dependencies (Ubuntu only)
        if: contains(matrix.platform, 'ubuntu') && steps.should_build.outputs.build == 'true'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libayatana-appindicator3-dev librsvg2-dev patchelf xdg-utils
          sudo apt-get install -y libwebkit2gtk-4.0-dev || true
          sudo apt-get install -y rpm
          sudo apt-get install -y libpcsclite-dev swig
      
      - name: Install frontend dependencies
        if: steps.should_build.outputs.build == 'true'
        run: npm install --prefix src-ui

      # Binary dependencies - fetch from GitHub Release
      - name: Cache Binary Dependencies
        if: steps.should_build.outputs.build == 'true'
        uses: actions/cache@v4
        with:
          path: src-tauri/bin/
          key: binaries-${{ runner.os }}-${{ matrix.platform_id }}-${{ hashFiles('src-tauri/bin/binary-dependencies.json') }}
          restore-keys: |
            binaries-${{ runner.os }}-${{ matrix.platform_id }}-
            binaries-${{ runner.os }}-

      - name: Fetch Binary Dependencies
        if: steps.should_build.outputs.build == 'true'
        run: |
          chmod +x scripts/cicd/fetch-binaries.sh
          ./scripts/cicd/fetch-binaries.sh
        shell: bash

      - name: Verify Binary Dependencies
        if: steps.should_build.outputs.build == 'true'
        run: |
          # Verify binaries were downloaded
          echo "Verifying binaries for ${{ matrix.platform }}..."

          if [[ "${{ matrix.platform }}" == "macos-latest" ]]; then
            PLATFORM_DIR="darwin"
          elif [[ "${{ matrix.platform }}" == *"ubuntu"* ]]; then
            PLATFORM_DIR="linux"
          else
            PLATFORM_DIR="windows"
          fi

          # Check required binaries exist (handle .exe extension on Windows)
          for binary in age age-plugin-yubikey ykman; do
            if [ "$PLATFORM_DIR" = "windows" ]; then
              # On Windows, check for .exe files
              if [ ! -e "src-tauri/bin/$PLATFORM_DIR/${binary}.exe" ] && [ ! -e "src-tauri/bin/$PLATFORM_DIR/${binary}.bat" ]; then
                echo "‚ùå ERROR: Binary not found: ${binary}.exe or ${binary}.bat"
                exit 1
              fi
            else
              # On Unix platforms, check without extension
              if [ ! -e "src-tauri/bin/$PLATFORM_DIR/$binary" ]; then
                echo "‚ùå ERROR: Binary not found: $binary"
                exit 1
              fi
            fi
          done

          # Check ykman-bundle exists
          if [ ! -d "src-tauri/bin/$PLATFORM_DIR/ykman-bundle" ]; then
            echo "‚ùå ERROR: ykman-bundle directory not found"
            exit 1
          fi

          echo "‚úÖ All binaries verified for $PLATFORM_DIR"
        shell: bash

      - name: Build with Tauri
        if: steps.should_build.outputs.build == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_DEVELOPER_ID }}
          SCCACHE_GHA_ENABLED: "true"
          RUSTC_WRAPPER: "sccache"
        shell: bash
        run: |
          cd src-tauri
          if [[ "${{ matrix.platform }}" == "macos-latest" ]]; then
            # macOS: Build only .app bundle (NOT DMG yet - we'll create DMG after signing)
            cargo tauri build ${{ matrix.args }} --bundles app
          else
            # Linux/Windows: Build all bundles normally
            cargo tauri build ${{ matrix.args }}
          fi

      # Diagnostic: Check code signing identities available
      - name: Verify Code Signing Identity (macOS)
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        shell: bash
        run: |
          echo "üîé Listing code signing identities on runner:"
          security find-identity -v -p codesigning || true

      # Post-build: Sign all Mach-O files inside the .app bundle
      - name: Sign Bundled Binaries Inside .app (macOS)
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        id: sign-app
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_DEVELOPER_ID }}
        shell: bash
        run: |
          echo "üîê Post-build signing: all Mach-O files inside .app bundle..."

          # Locate the built .app
          if [ "${{ matrix.arch }}" = "intel" ]; then
            APP_DIR="target/x86_64-apple-darwin/release/bundle/macos"
          else
            APP_DIR="target/aarch64-apple-darwin/release/bundle/macos"
          fi

          APP_PATH=$(find "$APP_DIR" -maxdepth 1 -name "*.app" -type d | head -1)
          echo "Found app: $APP_PATH"
          echo "app-path=$APP_PATH" >> $GITHUB_OUTPUT

          if [ ! -d "$APP_PATH" ]; then
            echo "‚ùå ERROR: .app bundle not found!"
            exit 1
          fi

          # Clear quarantine attributes
          xattr -r -d com.apple.quarantine "$APP_PATH" 2>/dev/null || true

          signed_count=0

          # Sign every Mach-O file inside .app
          # Don't rely only on -perm (some .so files might not have exec bit)
          # Explicitly include known patterns
          /usr/bin/find "$APP_PATH" -type f \
            \( -name "*.dylib" -o -name "*.so" -o -name "*.bundle" -o -name "age" -o -name "age-plugin-yubikey" -o -name "ykman" -o -path "*/Contents/MacOS/*" \) \
            -print0 | while IFS= read -r -d '' file; do

            # Verify it's actually a Mach-O file
            if file "$file" | grep -q "Mach-O"; then
              echo "Signing: $file"

              # Remove any existing signature
              /usr/bin/codesign --remove-signature "$file" 2>/dev/null || true

              # Sign with Developer ID + timestamp + hardened runtime
              /usr/bin/codesign --force \
                --sign "$APPLE_SIGNING_IDENTITY" \
                --options runtime \
                --timestamp \
                "$file" || {
                  echo "‚ùå Failed to sign $file"
                  exit 1
                }

              signed_count=$((signed_count + 1))
            fi
          done

          echo "‚úÖ Signed $signed_count Mach-O files inside .app"

          # Sign the .app bundle itself last (inside-out order)
          echo "üîê Signing .app bundle itself..."
          /usr/bin/codesign --force --deep \
            --sign "$APPLE_SIGNING_IDENTITY" \
            --options runtime \
            --timestamp \
            "$APP_PATH"

          # Verify signatures
          echo "üîç Verifying signatures..."
          /usr/bin/codesign --verify --deep --strict --verbose=4 "$APP_PATH"
          /usr/sbin/spctl --assess --type execute --verbose=4 "$APP_PATH" || true

          echo "üéâ All signing complete and verified"

      # Diagnostic: Verify specific problem files are signed
      - name: Inspect Problem Files (macOS)
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        shell: bash
        run: |
          APP="${{ steps.sign-app.outputs.app-path }}"
          AGE="$APP/Contents/Resources/bin/darwin/age"
          SCARD="$APP/Contents/Resources/bin/darwin/ykman-bundle/_internal/smartcard/scard/_scard.cpython-312-darwin.so"

          echo "üîç Inspecting signatures on problem files..."
          for f in "$AGE" "$SCARD"; do
            if [ -f "$f" ]; then
              echo "‚îÅ‚îÅ‚îÅ $f ‚îÅ‚îÅ‚îÅ"
              file "$f" || true
              echo "Signature details:"
              codesign -dv --verbose=4 "$f" 2>&1 | grep -E "Authority|Timestamp|Runtime" || echo "‚ö†Ô∏è Missing signature info"
              echo ""
            else
              echo "‚ö†Ô∏è File not found: $f"
            fi
          done

      # Create DMG from signed .app bundle
      - name: Create DMG from Signed App (macOS)
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        shell: bash
        run: |
          echo "üì¶ Creating DMG from signed .app bundle..."

          # Locate the signed .app
          if [ "${{ matrix.arch }}" = "intel" ]; then
            APP_DIR="target/x86_64-apple-darwin/release/bundle/macos"
          else
            APP_DIR="target/aarch64-apple-darwin/release/bundle/macos"
          fi

          APP_PATH=$(find "$APP_DIR" -maxdepth 1 -name "*.app" -type d | head -1)
          APP_NAME=$(basename "$APP_PATH")

          # Create DMG output directory
          DMG_DIR="$(dirname "$APP_DIR")/dmg"
          mkdir -p "$DMG_DIR"

          # DMG filename
          if [ "${{ matrix.arch }}" = "intel" ]; then
            DMG_NAME="Barqly Vault_0.2.0_x64.dmg"
          else
            DMG_NAME="Barqly Vault_0.2.0_aarch64.dmg"
          fi

          DMG_PATH="$DMG_DIR/$DMG_NAME"

          # Create DMG using hdiutil
          echo "Creating DMG: $DMG_PATH"
          hdiutil create "$DMG_PATH" \
            -volname "Barqly Vault" \
            -fs HFS+ \
            -srcfolder "$APP_PATH" \
            -ov \
            -format UDZO

          echo "‚úÖ DMG created: $DMG_PATH"
          ls -lh "$DMG_PATH"

      # Verify binaries in bundled artifacts (Post-Bundle Verification)
      - name: Verify Binaries in Bundled Artifacts
        if: steps.should_build.outputs.build == 'true'
        shell: bash
        run: |
          echo "üîç Verifying binaries in bundled artifacts..."

          if [[ "${{ matrix.platform }}" == "macos-latest" ]]; then
            # macOS: Find and mount DMG
            DMG=$(find target/*/release/bundle/dmg -name "*.dmg" | head -1)
            echo "Found DMG: $DMG"

            # Mount the DMG to a deterministic path
            MOUNT_POINT=$(mktemp -d)
            hdiutil attach "$DMG" -mountpoint "$MOUNT_POINT" -nobrowse -quiet

            # Verify binaries exist in app bundle
            APP="$MOUNT_POINT/Barqly Vault.app"
            echo "Checking binaries in: $APP/Contents/Resources/bin/darwin/"

            test -f "$APP/Contents/Resources/bin/darwin/age" || { echo "‚ùå age missing"; exit 1; }
            test -f "$APP/Contents/Resources/bin/darwin/age-plugin-yubikey" || { echo "‚ùå age-plugin-yubikey missing"; exit 1; }
            test -f "$APP/Contents/Resources/bin/darwin/ykman" || { echo "‚ùå ykman wrapper missing"; exit 1; }
            test -d "$APP/Contents/Resources/bin/darwin/ykman-bundle" || { echo "‚ùå ykman-bundle missing"; exit 1; }
            test -f "$APP/Contents/Resources/bin/darwin/ykman-bundle/ykman" || { echo "‚ùå ykman binary missing"; exit 1; }

            # Unmount and cleanup
            hdiutil detach "$MOUNT_POINT" -quiet
            rm -rf "$MOUNT_POINT"
            echo "‚úÖ macOS binaries verified in DMG"

          elif [[ "${{ matrix.platform }}" == *"ubuntu"* ]]; then
            # Linux: Extract and verify AppImage
            APPIMAGE=$(find target/*/release/bundle/appimage -name "*.AppImage" | head -1)
            echo "Found AppImage: $APPIMAGE"

            # Make it executable and extract
            chmod +x "$APPIMAGE"
            "$APPIMAGE" --appimage-extract > /dev/null 2>&1

            # Use find to locate binaries (Tauri bundles at different paths)
            echo "Searching for binaries in extracted AppImage..."
            echo "AppImage structure:"
            find squashfs-root -type d -name "bin" 2>/dev/null | head -5

            # Look for age binary - check multiple possible paths
            AGE_PATH=$(find squashfs-root -path "*/bin/linux/age" -o -path "*/bin/age" | head -1)
            test -n "$AGE_PATH" || { echo "‚ùå age not found in AppImage"; exit 1; }
            echo "‚úì Found age at: $AGE_PATH"

            # Look for age-plugin-yubikey
            PLUGIN_PATH=$(find squashfs-root -path "*/bin/linux/age-plugin-yubikey" -o -path "*/bin/age-plugin-yubikey" | head -1)
            test -n "$PLUGIN_PATH" || { echo "‚ùå age-plugin-yubikey not found in AppImage"; exit 1; }
            echo "‚úì Found age-plugin-yubikey at: $PLUGIN_PATH"

            # Look for ykman wrapper
            YKMAN_PATH=$(find squashfs-root -path "*/bin/linux/ykman" -o -path "*/bin/ykman" | head -1)
            test -n "$YKMAN_PATH" || { echo "‚ùå ykman not found in AppImage"; exit 1; }
            echo "‚úì Found ykman at: $YKMAN_PATH"

            # Look for ykman-bundle directory
            BUNDLE_PATH=$(find squashfs-root -path "*/bin/linux/ykman-bundle" -o -path "*/bin/ykman-bundle" -type d | head -1)
            test -n "$BUNDLE_PATH" || { echo "‚ùå ykman-bundle not found in AppImage"; exit 1; }
            echo "‚úì Found ykman-bundle at: $BUNDLE_PATH"

            # Verify ykman binary inside bundle
            test -f "$BUNDLE_PATH/ykman" || { echo "‚ùå ykman binary missing from bundle"; exit 1; }

            # Clean up
            rm -rf squashfs-root
            echo "‚úÖ Linux binaries verified in AppImage"

          elif [[ "${{ matrix.platform }}" == "windows-latest" ]]; then
            # Windows: Extract and verify MSI contents
            # First find the MSI file
            MSI=$(find target/*/release/bundle/msi -name "*.msi" | head -1)
            echo "Found MSI: $MSI"

            # Convert to Windows path for PowerShell
            MSI_WIN=$(cygpath -w "$MSI" 2>/dev/null || echo "$MSI")

            # Use msiexec to extract MSI (native Windows tool for proper extraction)
            echo "Extracting MSI contents with msiexec..."
            powershell -Command "
              # Create extraction directory with full path
              \$target = Join-Path (Get-Location) 'msi_extracted'
              New-Item -ItemType Directory -Path \$target -Force | Out-Null

              # Use msiexec /a for administrative installation (proper extraction)
              Write-Host 'Extracting MSI contents using msiexec /a...'
              Write-Host \"MSI Path: $MSI_WIN\"
              Write-Host \"Target Dir: \$target\"

              # Start msiexec process and wait for completion
              \$process = Start-Process msiexec.exe -ArgumentList '/a', \"\"\"$MSI_WIN\"\"\", '/qn', \"TARGETDIR=\$target\" -Wait -PassThru -NoNewWindow

              if (\$process.ExitCode -eq 0) {
                Write-Host '‚úì MSI extracted successfully'

                # Show extracted structure
                Write-Host 'Extracted structure:'
                Get-ChildItem -Path \$target -Directory | Select-Object -First 5 | ForEach-Object { Write-Host \$_.FullName }

                Write-Host 'Binary files found:'
                Get-ChildItem -Path \$target -Recurse -Include '*.exe','*.bat' | Select-Object -First 20 | ForEach-Object { Write-Host \$_.FullName }

                # Also check specific expected paths
                Write-Host 'Checking for Barqly Vault resources:'
                if (Test-Path \"\$target\ProgramFiles64Folder\") {
                  Get-ChildItem -Path \"\$target\ProgramFiles64Folder\" -Recurse -Include '*.exe','*.bat' | ForEach-Object { Write-Host \"Found: \$(\$_.FullName)\" }
                }
                if (Test-Path \"\$target\PFiles\") {
                  Get-ChildItem -Path \"\$target\PFiles\" -Recurse -Include '*.exe','*.bat' | ForEach-Object { Write-Host \"Found: \$(\$_.FullName)\" }
                }
              } else {
                Write-Host \"‚ùå MSI extraction failed with exit code: \$(\$process.ExitCode)\"
                exit 1
              }
            "

            # Verify binaries in bash (cross-platform compatible)
            echo "Verifying binaries in extracted MSI..."

            if [ -d "msi_extracted" ]; then
              echo "MSI structure:"
              find msi_extracted -type d -name "bin" 2>/dev/null | head -5
              echo "Binary files in MSI:"
              find msi_extracted -type f \( -name "*.exe" -o -name "*.bat" \) 2>/dev/null | head -20

              # Check for required binaries (flexible path checking)
              if ! find msi_extracted -name "age.exe" 2>/dev/null | grep -q .; then
                echo "‚ùå age.exe not found in MSI package"; exit 1
              fi
              if ! find msi_extracted -name "age-plugin-yubikey.exe" 2>/dev/null | grep -q .; then
                echo "‚ùå age-plugin-yubikey.exe not found in MSI package"; exit 1
              fi
              if ! find msi_extracted \( -name "ykman.bat" -o -name "ykman.exe" \) 2>/dev/null | grep -q .; then
                echo "‚ùå ykman not found in MSI package"; exit 1
              fi

              # Verify ykman-bundle exists
              if ! find msi_extracted -type d -name "ykman-bundle" 2>/dev/null | grep -q .; then
                echo "‚ùå ykman-bundle directory not found in MSI package"; exit 1
              fi

              echo "‚úÖ Windows binaries verified in MSI package"

              # Also check staging directory as a secondary verification
              echo "Secondary check - staging directory:"
              test -f "src-tauri/bin/windows/age.exe" && echo "  ‚úì age.exe in staging"
              test -f "src-tauri/bin/windows/age-plugin-yubikey.exe" && echo "  ‚úì age-plugin-yubikey.exe in staging"
              test -f "src-tauri/bin/windows/ykman.bat" && echo "  ‚úì ykman.bat in staging"
              test -d "src-tauri/bin/windows/ykman-bundle" && echo "  ‚úì ykman-bundle in staging"
            else
              echo "‚ùå msi_extracted directory not found"; exit 1
            fi

            # Clean up
            rm -rf msi_extracted
          fi

          echo "‚úÖ Post-bundle verification complete for ${{ matrix.platform }}"

      # Find and notarize macOS DMG
      - name: Find DMG Path
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        id: find-dmg
        run: |
          if [ "${{ matrix.arch }}" = "intel" ]; then
            DMG_DIR="${{ github.workspace }}/target/x86_64-apple-darwin/release/bundle/dmg"
          else
            DMG_DIR="${{ github.workspace }}/target/aarch64-apple-darwin/release/bundle/dmg"
          fi
          DMG_PATH=$(find "$DMG_DIR" -name "*.dmg" -type f | head -1)
          echo "dmg-path=$DMG_PATH" >> $GITHUB_OUTPUT
        shell: bash
      
      - name: Notarize macOS DMG
        if: |
          matrix.platform == 'macos-latest' &&
          steps.should_build.outputs.build == 'true' &&
          !contains(github.ref, '-test.')
        uses: ./.github/actions/notarize-macos
        with:
          dmg-path: ${{ steps.find-dmg.outputs.dmg-path }}
          api-key: ${{ secrets.APPLE_API_KEY }}
          api-key-id: ${{ secrets.APPLE_API_KEY_ID }}
          api-issuer-id: ${{ secrets.APPLE_API_ISSUER_ID }}
      
      # Extract version from tag or input
      - name: Extract Version
        if: steps.should_build.outputs.build == 'true'
        id: version
        run: |
          if [[ "$GITHUB_REF" =~ refs/tags/v?(.+) ]]; then
            VERSION="${BASH_REMATCH[1]}"
          elif [[ -n "${{ github.event.inputs.version }}" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="dev"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
        shell: bash
      
      # Rename artifacts with consistent naming
      - name: Rename Artifacts
        if: steps.should_build.outputs.build == 'true'
        uses: ./.github/actions/rename-artifacts
        with:
          platform: ${{ matrix.platform }}
          arch: ${{ matrix.arch }}
          version: ${{ steps.version.outputs.version }}
      
      # Upload renamed artifacts
      - name: Upload artifacts
        if: steps.should_build.outputs.build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: barqly-vault-${{ matrix.platform }}-${{ matrix.arch }}
          path: renamed-artifacts/*
          retention-days: 7
      
      # Cleanup Apple keychain
      - name: Cleanup Apple Keychain
        if: always() && matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        uses: ./.github/actions/apple-certificates
        with:
          operation: cleanup

  # Create beta release with all artifacts
  create-beta-release:
    name: Create Beta Release
    needs: [publish-tauri]
    if: |
      always() && 
      github.event.inputs.promote_from == '' &&
      (needs.publish-tauri.result == 'success' || inputs.release_only == true) &&
      (startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Extract version
        id: get_version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION=${GITHUB_REF#refs/tags/v}
          fi
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "üì¶ Creating release for version: $VERSION"
      
      # Download all artifacts from build job
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        if: inputs.release_only != true
        with:
          path: release-artifacts
      
      # Download artifacts from previous run when release_only
      - name: Download artifacts from previous run
        if: inputs.release_only == true
        run: |
          echo "üîç Finding the most recent successful build for v${{ steps.get_version.outputs.VERSION }}..."
          
          RUN_ID=$(gh run list \
            --workflow=release.yml \
            --branch="v${{ steps.get_version.outputs.VERSION }}" \
            --status=completed \
            --limit=10 \
            --json databaseId,conclusion \
            --jq '.[] | select(.conclusion == "success" or .conclusion == "failure") | .databaseId' | head -1)
          
          if [ -z "$RUN_ID" ]; then
            echo "‚ùå No previous runs found for v${{ steps.get_version.outputs.VERSION }}"
            exit 1
          fi
          
          echo "üì• Downloading artifacts from run $RUN_ID..."
          mkdir -p release-artifacts
          gh run download $RUN_ID --dir release-artifacts
          echo "‚úÖ Downloaded artifacts from run $RUN_ID"
        env:
          GH_TOKEN: ${{ github.token }}
      
      - name: Prepare release assets
        run: |
          mkdir -p release-assets
          
          # Move all artifacts to release-assets, flattening structure
          find release-artifacts -type f \( \
            -name "*.dmg" -o \
            -name "*.exe" -o \
            -name "*.msi" -o \
            -name "*.deb" -o \
            -name "*.rpm" -o \
            -name "*.AppImage" -o \
            -name "*.tar.gz" -o \
            -name "*.zip" \
          \) -exec cp {} release-assets/ \;
          
          echo "üì¶ Final release assets:"
          ls -la release-assets/
      
      - name: Generate checksums
        uses: ./.github/actions/create-checksums
        with:
          artifacts-dir: release-assets
      
      # Clean up any existing release
      - name: Delete existing release if present
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          
          if gh release view "v$VERSION" &>/dev/null; then
            echo "‚ö†Ô∏è Found existing release for v$VERSION, deleting it..."
            gh release delete "v$VERSION" --yes
            echo "‚úÖ Existing release deleted"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Generate release notes
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          ./scripts/cicd/generate-release-notes.sh "$VERSION" > release-notes.md
      
      - name: Create draft release
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          
          gh release create "v$VERSION" \
            --draft \
            --title "Barqly Vault v$VERSION" \
            --notes-file release-notes.md \
            release-assets/*
          
          echo "‚úÖ Beta release created for v$VERSION"
          echo "üìù Review and publish at: https://github.com/${{ github.repository }}/releases"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Automatically create production release draft when beta is created
  create-production-release:
    name: Create Production Release
    needs: [create-beta-release]
    if: |
      needs.create-beta-release.result == 'success' && 
      contains(github.ref, '-beta')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Extract version and create production version
        id: get_version
        run: |
          # Get the beta version from tag
          BETA_VERSION=${GITHUB_REF#refs/tags/v}
          echo "BETA_VERSION=$BETA_VERSION" >> $GITHUB_OUTPUT
          
          # Extract production version from beta.N format (e.g., 1.0.0-beta.3 -> 1.0.0)
          if [[ "$BETA_VERSION" =~ ^([0-9]+\.[0-9]+\.[0-9]+)-beta\.[0-9]+$ ]]; then
            PROD_VERSION="${BASH_REMATCH[1]}"
          else
            echo "‚ùå ERROR: Invalid beta version format. Expected format: X.Y.Z-beta.N"
            exit 1
          fi
          echo "PROD_VERSION=$PROD_VERSION" >> $GITHUB_OUTPUT
          
          echo "üì¶ Creating production release draft for v$PROD_VERSION from beta v$BETA_VERSION"
      
      - name: Download beta release assets
        run: |
          # Download all assets from the beta release
          mkdir -p production-assets
          
          gh release download "v${{ steps.get_version.outputs.BETA_VERSION }}" \
            --dir production-assets \
            --repo ${{ github.repository }}
          
          echo "üì• Downloaded beta assets:"
          ls -la production-assets/
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Rename artifacts for production
        run: |
          cd production-assets
          
          BETA_VERSION="${{ steps.get_version.outputs.BETA_VERSION }}"
          PROD_VERSION="${{ steps.get_version.outputs.PROD_VERSION }}"
          
          echo "üìù Renaming artifacts from $BETA_VERSION to $PROD_VERSION..."
          
          # Rename all files that contain the beta version string
          for file in *; do
            if [[ "$file" == *"$BETA_VERSION"* ]]; then
              new_name="${file//$BETA_VERSION/$PROD_VERSION}"
              mv "$file" "$new_name"
              echo "  Renamed: $file ‚Üí $new_name"
            fi
          done
          
          # Regenerate checksums with new filenames
          if [ -f "checksums.txt" ]; then
            echo "üìù Regenerating checksums..."
            rm checksums.txt
            shasum -a 256 * > checksums.txt
            echo "‚úÖ Checksums regenerated"
          fi
          
          echo "üì¶ Final production artifacts:"
          ls -la
      
      - name: Create production tag
        run: |
          # Configure git identity for tagging
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "GitHub Actions"
          
          # Delete existing tag if it exists (from previous failed runs)
          git push origin --delete "v${{ steps.get_version.outputs.PROD_VERSION }}" 2>/dev/null || true
          
          # Create a production tag pointing to the same commit as beta
          git tag "v${{ steps.get_version.outputs.PROD_VERSION }}" -m "Production release from v${{ steps.get_version.outputs.BETA_VERSION }}"
          git push origin "v${{ steps.get_version.outputs.PROD_VERSION }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Generate production release notes
        run: |
          PROD_VERSION="${{ steps.get_version.outputs.PROD_VERSION }}"
          ./scripts/cicd/generate-release-notes.sh "$PROD_VERSION" > release-notes.md
      
      - name: Create production draft release
        run: |
          PROD_VERSION="${{ steps.get_version.outputs.PROD_VERSION }}"
          
          gh release create "v$PROD_VERSION" \
            --draft \
            --title "Barqly Vault v$PROD_VERSION" \
            --notes-file release-notes.md \
            production-assets/*
          
          echo "‚úÖ Production draft release created for v$PROD_VERSION"
          echo "üìù Ready to publish at: https://github.com/${{ github.repository }}/releases"
          echo ""
          echo "‚ö†Ô∏è This is a DRAFT - manually publish when ready for production!"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

