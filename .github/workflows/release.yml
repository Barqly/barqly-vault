name: Release Pipeline

on:
  push:
    tags:
      - 'v*.*.*-beta*'   # Beta tags (both old format and new .N format)
      - 'v*.*.*-beta.*'  # New incremental format: v1.0.0-beta.1, v1.0.0-beta.2, etc.
      # This ensures:
      # - Alpha tags (checkpoints) don't trigger builds
      # - Production tags (from promotion) don't trigger builds
      # - Only intentional beta testing triggers CI/CD
  
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.0)'
        required: false
      promote_from:
        description: 'Beta version to promote (e.g., 1.0.0-beta.3 or 1.0.0-beta) - leave empty for new build'
        required: false
      list_available_betas:
        description: 'List available beta releases for promotion (check this to see options)'
        type: boolean
        default: false
      prerelease:
        description: 'Mark as pre-release'
        type: boolean
        default: false
      release_only:
        description: 'Skip build and only create release from existing artifacts'
        required: false
        type: boolean
        default: false
      selective_build:
        description: 'Enable selective platform building (for testing)'
        type: boolean
        default: false
      build_macos_intel:
        description: 'Build macOS Intel (x86_64)'
        type: boolean
        default: true
      build_macos_arm:
        description: 'Build macOS ARM (Apple Silicon)'
        type: boolean
        default: true
      build_linux:
        description: 'Build Linux'
        type: boolean
        default: true
      build_windows:
        description: 'Build Windows'
        type: boolean
        default: true

jobs:
  # List available beta releases for promotion
  list-betas:
    if: github.event.inputs.list_available_betas == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: List Available Beta Releases
        run: |
          echo "## üìã Available Beta Releases for Promotion" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Version | Created | Status | Assets |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|---------|---------|---------|" >> $GITHUB_STEP_SUMMARY
          
          # List all beta releases (published and draft)
          gh release list \
            --repo ${{ github.repository }} \
            --limit 20 \
            --json tagName,name,createdAt,isDraft \
            --jq '.[] | select(.tagName | test("-beta")) | [.tagName, .createdAt[:10], (if .isDraft then "Draft" else "Published" end)] | @csv' \
          | while IFS=',' read -r tag date status; do
            # Clean up CSV formatting
            tag=$(echo "$tag" | tr -d '"')
            date=$(echo "$date" | tr -d '"')
            status=$(echo "$status" | tr -d '"')
            
            # Count assets for this release
            asset_count=$(gh release view "$tag" --repo ${{ github.repository }} --json assets --jq '.assets | length' 2>/dev/null || echo "0")
            
            echo "| \`$tag\` | $date | $status | $asset_count |" >> $GITHUB_STEP_SUMMARY
          done
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Usage:** Re-run this workflow with \`promote_from\` set to one of the beta versions above." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Example:** \`promote_from: 1.0.0-beta.3\` and \`version: 1.0.0\`" >> $GITHUB_STEP_SUMMARY
        env:
          GH_TOKEN: ${{ github.token }}

  # Handle promotion workflow when promote_from is specified
  promote:
    if: github.event.inputs.promote_from != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      
      - name: Promote Release
        uses: ./.github/actions/promote-release
        with:
          source-version: ${{ github.event.inputs.promote_from }}
          target-version: ${{ github.event.inputs.version }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          draft: true
      
      - name: Summary
        run: |
          echo "## üéâ Release Promoted Successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **From**: v${{ github.event.inputs.promote_from }}" >> $GITHUB_STEP_SUMMARY
          echo "- **To**: v${{ github.event.inputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: Draft (ready for manual publish)" >> $GITHUB_STEP_SUMMARY

  # Main build and release workflow
  publish-tauri:
    # Skip if we're promoting or only creating a release
    if: github.event.inputs.promote_from == '' && inputs.release_only != true
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          # macOS Intel
          - platform: 'macos-latest'
            args: '--target x86_64-apple-darwin'
            arch: 'intel'
            label: 'macOS (Intel)'
            platform_id: 'macos_intel'
          
          # macOS Apple Silicon
          - platform: 'macos-latest'
            args: '--target aarch64-apple-darwin'
            arch: 'apple-silicon'
            label: 'macOS (Apple M-series)'
            platform_id: 'macos_arm'
          
          # Linux x64 - Standard Linux desktops (.deb, .rpm, .appimage, .tar.gz)
          - platform: 'ubuntu-22.04'
            args: '--target x86_64-unknown-linux-gnu'
            arch: 'x64'
            label: 'Linux'
            platform_id: 'linux'
          
          # Windows x64
          - platform: 'windows-latest'
            args: '--target x86_64-pc-windows-msvc'
            arch: 'x64'
            label: 'Windows'
            platform_id: 'windows'

    runs-on: ${{ matrix.platform }}
    
    steps:
      # Check if this platform should be built based on selective build settings
      - name: Check Platform Build Condition
        id: should_build
        run: |
          # For tag pushes, check if it's a test tag with platform specifications
          if [[ "${{ github.event_name }}" == "push" ]]; then
            TAG="${GITHUB_REF#refs/tags/}"
            echo "üè∑Ô∏è Processing tag: $TAG"
            
            # Check if this is a beta tag with selective platforms
            if [[ "$TAG" == *"-beta-"* ]]; then
              echo "üß™ Beta tag with platform selection detected..."
              
              # Extract platform list after "-beta-" if present (skip .N format)
              if [[ "$TAG" =~ -beta-(.+)$ ]] && [[ ! "$TAG" =~ -beta\.[0-9]+$ ]]; then
                PLATFORMS="${BASH_REMATCH[1]}"
                echo "üìã Specified platforms: $PLATFORMS"
                
                # Check if current platform is in the list
                case "${{ matrix.platform_id }}" in
                  macos_intel|macos_arm)
                    if [[ "$PLATFORMS" == *"mac"* ]]; then
                      echo "build=true" >> $GITHUB_OUTPUT
                      echo "‚úÖ Building macOS (specified in test tag)"
                    else
                      echo "build=false" >> $GITHUB_OUTPUT
                      echo "‚è≠Ô∏è Skipping macOS (not specified in test tag)"
                    fi
                    ;;
                  linux)
                    if [[ "$PLATFORMS" == *"linux"* ]]; then
                      echo "build=true" >> $GITHUB_OUTPUT
                      echo "‚úÖ Building Linux (specified in test tag)"
                    else
                      echo "build=false" >> $GITHUB_OUTPUT
                      echo "‚è≠Ô∏è Skipping Linux (not specified in test tag)"
                    fi
                    ;;
                  windows)
                    if [[ "$PLATFORMS" == *"win"* ]]; then
                      echo "build=true" >> $GITHUB_OUTPUT
                      echo "‚úÖ Building Windows (specified in test tag)"
                    else
                      echo "build=false" >> $GITHUB_OUTPUT
                      echo "‚è≠Ô∏è Skipping Windows (not specified in test tag)"
                    fi
                    ;;
                esac
              else
                # Beta tag without platform spec - build all platforms
                echo "build=true" >> $GITHUB_OUTPUT
                echo "‚úÖ Building (beta release - all platforms)"
              fi
            else
              # Regular tag - build everything
              echo "build=true" >> $GITHUB_OUTPUT
              echo "‚úÖ Building (production tag - all platforms)"
            fi
          # For workflow_dispatch, check selective build settings
          elif [[ "${{ inputs.selective_build }}" != "true" ]]; then
            echo "build=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Building (selective build disabled - all platforms)"
          else
            # Selective build is enabled, check individual platform settings
            case "${{ matrix.platform_id }}" in
              macos_intel)
                if [[ "${{ inputs.build_macos_intel }}" == "true" ]]; then
                  echo "build=true" >> $GITHUB_OUTPUT
                  echo "‚úÖ Building macOS Intel (selected)"
                else
                  echo "build=false" >> $GITHUB_OUTPUT
                  echo "‚è≠Ô∏è Skipping macOS Intel (not selected)"
                fi
                ;;
              macos_arm)
                if [[ "${{ inputs.build_macos_arm }}" == "true" ]]; then
                  echo "build=true" >> $GITHUB_OUTPUT
                  echo "‚úÖ Building macOS ARM (selected)"
                else
                  echo "build=false" >> $GITHUB_OUTPUT
                  echo "‚è≠Ô∏è Skipping macOS ARM (not selected)"
                fi
                ;;
              linux_x64|linux_arm64)
                if [[ "${{ inputs.build_linux }}" == "true" ]]; then
                  echo "build=true" >> $GITHUB_OUTPUT
                  echo "‚úÖ Building Linux ${{ matrix.arch }} (selected)"
                else
                  echo "build=false" >> $GITHUB_OUTPUT
                  echo "‚è≠Ô∏è Skipping Linux ${{ matrix.arch }} (not selected)"
                fi
                ;;
              windows)
                if [[ "${{ inputs.build_windows }}" == "true" ]]; then
                  echo "build=true" >> $GITHUB_OUTPUT
                  echo "‚úÖ Building Windows (selected)"
                else
                  echo "build=false" >> $GITHUB_OUTPUT
                  echo "‚è≠Ô∏è Skipping Windows (not selected)"
                fi
                ;;
            esac
          fi
        shell: bash
      
      # Skip this job if platform is not selected
      - name: Skip Job if Platform Not Selected
        if: steps.should_build.outputs.build == 'false'
        run: |
          echo "Platform not selected for build, exiting successfully"
          exit 0
        shell: bash
      
      - uses: actions/checkout@v4
        if: steps.should_build.outputs.build == 'true'
      
      # Setup Apple certificate for macOS signing
      - name: Setup Apple Certificate
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        uses: ./.github/actions/apple-certificates
        with:
          certificate-p12: ${{ secrets.APPLE_CERTIFICATE_P12 }}
          certificate-password: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          operation: setup
      
      - name: Setup Node
        if: steps.should_build.outputs.build == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: 'npm'
      
      - name: Install Rust stable
        if: steps.should_build.outputs.build == 'true'
        uses: dtolnay/rust-toolchain@87f07835889b686aca1fb3733c2aa2d61586c1e1
        with:
          toolchain: stable
          targets: ${{ matrix.arch == 'intel' && 'x86_64-apple-darwin' || matrix.arch == 'apple-silicon' && 'aarch64-apple-darwin' || matrix.arch == 'x64' && contains(matrix.platform, 'ubuntu') && 'x86_64-unknown-linux-gnu' || matrix.arch == 'arm64' && contains(matrix.platform, 'ubuntu') && 'aarch64-unknown-linux-gnu' || matrix.platform == 'windows-latest' && 'x86_64-pc-windows-msvc' }}
      
      - name: Rust cache
        if: steps.should_build.outputs.build == 'true'
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'
      
      - name: Install dependencies (Ubuntu only)
        if: contains(matrix.platform, 'ubuntu') && steps.should_build.outputs.build == 'true'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libayatana-appindicator3-dev librsvg2-dev patchelf xdg-utils
          sudo apt-get install -y libwebkit2gtk-4.0-dev || true
          sudo apt-get install -y rpm
      
      - name: Install frontend dependencies
        if: steps.should_build.outputs.build == 'true'
        run: npm install --prefix src-ui
      
      - name: Build with Tauri
        if: steps.should_build.outputs.build == 'true'
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_DEVELOPER_ID }}
        with:
          args: ${{ matrix.args }}
      
      # Find and notarize macOS DMG
      - name: Find DMG Path
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        id: find-dmg
        run: |
          if [ "${{ matrix.arch }}" = "intel" ]; then
            DMG_DIR="${{ github.workspace }}/target/x86_64-apple-darwin/release/bundle/dmg"
          else
            DMG_DIR="${{ github.workspace }}/target/aarch64-apple-darwin/release/bundle/dmg"
          fi
          DMG_PATH=$(find "$DMG_DIR" -name "*.dmg" -type f | head -1)
          echo "dmg-path=$DMG_PATH" >> $GITHUB_OUTPUT
        shell: bash
      
      - name: Notarize macOS DMG
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        uses: ./.github/actions/notarize-macos
        with:
          dmg-path: ${{ steps.find-dmg.outputs.dmg-path }}
          api-key: ${{ secrets.APPLE_API_KEY }}
          api-key-id: ${{ secrets.APPLE_API_KEY_ID }}
          api-issuer-id: ${{ secrets.APPLE_API_ISSUER_ID }}
      
      # Extract version from tag or input
      - name: Extract Version
        if: steps.should_build.outputs.build == 'true'
        id: version
        run: |
          if [[ "$GITHUB_REF" =~ refs/tags/v?(.+) ]]; then
            VERSION="${BASH_REMATCH[1]}"
          elif [[ -n "${{ github.event.inputs.version }}" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="dev"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
        shell: bash
      
      # Rename artifacts with consistent naming
      - name: Rename Artifacts
        if: steps.should_build.outputs.build == 'true'
        uses: ./.github/actions/rename-artifacts
        with:
          platform: ${{ matrix.platform }}
          arch: ${{ matrix.arch }}
          version: ${{ steps.version.outputs.version }}
      
      # Upload renamed artifacts
      - name: Upload artifacts
        if: steps.should_build.outputs.build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: barqly-vault-${{ matrix.platform }}-${{ matrix.arch }}
          path: renamed-artifacts/*
          retention-days: 7
      
      # Cleanup Apple keychain
      - name: Cleanup Apple Keychain
        if: always() && matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        uses: ./.github/actions/apple-certificates
        with:
          operation: cleanup

  # Create beta release with all artifacts
  create-beta-release:
    name: Create Beta Release
    needs: [publish-tauri]
    if: |
      always() && 
      github.event.inputs.promote_from == '' &&
      (needs.publish-tauri.result == 'success' || inputs.release_only == true) &&
      (startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Extract version
        id: get_version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION=${GITHUB_REF#refs/tags/v}
          fi
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "üì¶ Creating release for version: $VERSION"
      
      # Download all artifacts from build job
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        if: inputs.release_only != true
        with:
          path: release-artifacts
      
      # Download artifacts from previous run when release_only
      - name: Download artifacts from previous run
        if: inputs.release_only == true
        run: |
          echo "üîç Finding the most recent successful build for v${{ steps.get_version.outputs.VERSION }}..."
          
          RUN_ID=$(gh run list \
            --workflow=release.yml \
            --branch="v${{ steps.get_version.outputs.VERSION }}" \
            --status=completed \
            --limit=10 \
            --json databaseId,conclusion \
            --jq '.[] | select(.conclusion == "success" or .conclusion == "failure") | .databaseId' | head -1)
          
          if [ -z "$RUN_ID" ]; then
            echo "‚ùå No previous runs found for v${{ steps.get_version.outputs.VERSION }}"
            exit 1
          fi
          
          echo "üì• Downloading artifacts from run $RUN_ID..."
          mkdir -p release-artifacts
          gh run download $RUN_ID --dir release-artifacts
          echo "‚úÖ Downloaded artifacts from run $RUN_ID"
        env:
          GH_TOKEN: ${{ github.token }}
      
      - name: Prepare release assets
        run: |
          mkdir -p release-assets
          
          # Move all artifacts to release-assets, flattening structure
          find release-artifacts -type f \( \
            -name "*.dmg" -o \
            -name "*.exe" -o \
            -name "*.msi" -o \
            -name "*.deb" -o \
            -name "*.rpm" -o \
            -name "*.AppImage" -o \
            -name "*.tar.gz" -o \
            -name "*.zip" \
          \) -exec cp {} release-assets/ \;
          
          echo "üì¶ Final release assets:"
          ls -la release-assets/
      
      - name: Generate checksums
        uses: ./.github/actions/create-checksums
        with:
          artifacts-dir: release-assets
      
      # Clean up any existing release
      - name: Delete existing release if present
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          
          if gh release view "v$VERSION" &>/dev/null; then
            echo "‚ö†Ô∏è Found existing release for v$VERSION, deleting it..."
            gh release delete "v$VERSION" --yes
            echo "‚úÖ Existing release deleted"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Generate release notes
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          ./scripts/ci/generate-release-notes.sh "$VERSION" > release-notes.md
      
      - name: Create draft release
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          
          gh release create "v$VERSION" \
            --draft \
            --title "Barqly Vault v$VERSION" \
            --notes-file release-notes.md \
            release-assets/*
          
          echo "‚úÖ Beta release created for v$VERSION"
          echo "üìù Review and publish at: https://github.com/${{ github.repository }}/releases"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Automatically create production release draft when beta is created
  create-production-release:
    name: Create Production Release
    needs: [create-beta-release]
    if: |
      needs.create-beta-release.result == 'success' && 
      contains(github.ref, '-beta')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Extract version and create production version
        id: get_version
        run: |
          # Get the beta version from tag
          BETA_VERSION=${GITHUB_REF#refs/tags/v}
          echo "BETA_VERSION=$BETA_VERSION" >> $GITHUB_OUTPUT
          
          # Remove -beta suffix to get production version (handles both -beta and -beta.N formats)
          if [[ "$BETA_VERSION" =~ ^([0-9]+\.[0-9]+\.[0-9]+)-beta(\.[0-9]+)?$ ]]; then
            PROD_VERSION="${BASH_REMATCH[1]}"
          else
            # Fallback for old format
            PROD_VERSION=${BETA_VERSION%-beta*}
          fi
          echo "PROD_VERSION=$PROD_VERSION" >> $GITHUB_OUTPUT
          
          echo "üì¶ Creating production release draft for v$PROD_VERSION from beta v$BETA_VERSION"
      
      - name: Download beta release assets
        run: |
          # Download all assets from the beta release
          mkdir -p production-assets
          
          gh release download "v${{ steps.get_version.outputs.BETA_VERSION }}" \
            --dir production-assets \
            --repo ${{ github.repository }}
          
          echo "üì• Downloaded beta assets:"
          ls -la production-assets/
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Rename artifacts for production
        run: |
          cd production-assets
          
          BETA_VERSION="${{ steps.get_version.outputs.BETA_VERSION }}"
          PROD_VERSION="${{ steps.get_version.outputs.PROD_VERSION }}"
          
          echo "üìù Renaming artifacts from $BETA_VERSION to $PROD_VERSION..."
          
          # Rename all files that contain the beta version string
          for file in *; do
            if [[ "$file" == *"$BETA_VERSION"* ]]; then
              new_name="${file//$BETA_VERSION/$PROD_VERSION}"
              mv "$file" "$new_name"
              echo "  Renamed: $file ‚Üí $new_name"
            fi
          done
          
          # Regenerate checksums with new filenames
          if [ -f "checksums.txt" ]; then
            echo "üìù Regenerating checksums..."
            rm checksums.txt
            shasum -a 256 * > checksums.txt
            echo "‚úÖ Checksums regenerated"
          fi
          
          echo "üì¶ Final production artifacts:"
          ls -la
      
      - name: Create production tag
        run: |
          # Configure git identity for tagging
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "GitHub Actions"
          
          # Delete existing tag if it exists (from previous failed runs)
          git push origin --delete "v${{ steps.get_version.outputs.PROD_VERSION }}" 2>/dev/null || true
          
          # Create a production tag pointing to the same commit as beta
          git tag "v${{ steps.get_version.outputs.PROD_VERSION }}" -m "Production release from v${{ steps.get_version.outputs.BETA_VERSION }}"
          git push origin "v${{ steps.get_version.outputs.PROD_VERSION }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Generate production release notes
        run: |
          PROD_VERSION="${{ steps.get_version.outputs.PROD_VERSION }}"
          ./scripts/ci/generate-release-notes.sh "$PROD_VERSION" > release-notes.md
      
      - name: Create production draft release
        run: |
          PROD_VERSION="${{ steps.get_version.outputs.PROD_VERSION }}"
          
          gh release create "v$PROD_VERSION" \
            --draft \
            --title "Barqly Vault v$PROD_VERSION" \
            --notes-file release-notes.md \
            production-assets/*
          
          echo "‚úÖ Production draft release created for v$PROD_VERSION"
          echo "üìù Ready to publish at: https://github.com/${{ github.repository }}/releases"
          echo ""
          echo "‚ö†Ô∏è This is a DRAFT - manually publish when ready for production!"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}