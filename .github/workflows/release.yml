name: Release Pipeline

on:
  push:
    tags:
      - 'v*.*.*-beta.*'  # Beta releases: v1.0.0-beta.1, v1.0.0-beta.2, etc.
      - 'v*.*.*-test.*'  # Test builds: v1.0.0-test.1 (skips notarization, saves costs)
      # This ensures:
      # - Alpha tags (v*.*.*-alpha.*) don't trigger builds (checkpoints only)
      # - Production tags (v*.*.*) don't trigger builds (manual promotion only)
      # - Beta tags trigger full CI/CD with notarization
      # - Test tags trigger full CI/CD WITHOUT notarization (for testing)
  
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.0)'
        required: false
      promote_from:
        description: 'Beta version to promote (e.g., 1.0.0-beta.3) - leave empty for new build'
        required: false
      list_available_betas:
        description: 'List available beta releases for promotion (check this to see options)'
        type: boolean
        default: false
      prerelease:
        description: 'Mark as pre-release'
        type: boolean
        default: false
      release_only:
        description: 'Skip build and only create release from existing artifacts'
        required: false
        type: boolean
        default: false
      selective_build:
        description: 'Enable selective platform building (for testing)'
        type: boolean
        default: false
      build_macos_intel:
        description: 'Build macOS Intel (x86_64)'
        type: boolean
        default: true
      build_macos_arm:
        description: 'Build macOS ARM (Apple Silicon)'
        type: boolean
        default: true
      build_linux:
        description: 'Build Linux'
        type: boolean
        default: true
      build_windows:
        description: 'Build Windows'
        type: boolean
        default: true

jobs:
  # List available beta releases for promotion
  list-betas:
    if: github.event.inputs.list_available_betas == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: List Available Beta Releases
        run: |
          echo "## üìã Available Beta Releases for Promotion" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Version | Created | Status | Assets |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|---------|---------|---------|" >> $GITHUB_STEP_SUMMARY
          
          # List all beta releases (published and draft)
          gh release list \
            --repo ${{ github.repository }} \
            --limit 20 \
            --json tagName,name,createdAt,isDraft \
            --jq '.[] | select(.tagName | test("-beta")) | [.tagName, .createdAt[:10], (if .isDraft then "Draft" else "Published" end)] | @csv' \
          | while IFS=',' read -r tag date status; do
            # Clean up CSV formatting
            tag=$(echo "$tag" | tr -d '"')
            date=$(echo "$date" | tr -d '"')
            status=$(echo "$status" | tr -d '"')
            
            # Count assets for this release
            asset_count=$(gh release view "$tag" --repo ${{ github.repository }} --json assets --jq '.assets | length' 2>/dev/null || echo "0")
            
            echo "| \`$tag\` | $date | $status | $asset_count |" >> $GITHUB_STEP_SUMMARY
          done
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Usage:** Re-run this workflow with \`promote_from\` set to one of the beta versions above." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Example:** \`promote_from: 1.0.0-beta.3\` and \`version: 1.0.0\`" >> $GITHUB_STEP_SUMMARY
        env:
          GH_TOKEN: ${{ github.token }}

  # Handle promotion workflow when promote_from is specified
  promote:
    if: github.event.inputs.promote_from != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      
      - name: Promote Release
        uses: ./.github/actions/promote-release
        with:
          source-version: ${{ github.event.inputs.promote_from }}
          target-version: ${{ github.event.inputs.version }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          draft: true
      
      - name: Summary
        run: |
          echo "## üéâ Release Promoted Successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **From**: v${{ github.event.inputs.promote_from }}" >> $GITHUB_STEP_SUMMARY
          echo "- **To**: v${{ github.event.inputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: Draft (ready for manual publish)" >> $GITHUB_STEP_SUMMARY

  # Main build and release workflow
  publish-tauri:
    # Skip if we're promoting or only creating a release
    if: github.event.inputs.promote_from == '' && inputs.release_only != true
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          # macOS Intel
          - platform: 'macos-latest'
            args: '--target x86_64-apple-darwin'
            arch: 'intel'
            label: 'macOS (Intel)'
            platform_id: 'macos_intel'
          
          # macOS Apple Silicon
          - platform: 'macos-latest'
            args: '--target aarch64-apple-darwin'
            arch: 'apple-silicon'
            label: 'macOS (Apple M-series)'
            platform_id: 'macos_arm'
          
          # Linux x64 - Standard Linux desktops (.deb, .rpm, .appimage, .tar.gz)
          - platform: 'ubuntu-22.04'
            args: '--target x86_64-unknown-linux-gnu'
            arch: 'x64'
            label: 'Linux'
            platform_id: 'linux'
          
          # Windows x64
          - platform: 'windows-latest'
            args: '--target x86_64-pc-windows-msvc'
            arch: 'x64'
            label: 'Windows'
            platform_id: 'windows'

    runs-on: ${{ matrix.platform }}
    
    steps:
      # Check if this platform should be built based on selective build settings
      - name: Check Platform Build Condition
        id: should_build
        run: |
          # For tag pushes, build all platforms (beta and test tags)
          if [[ "${{ github.event_name }}" == "push" ]]; then
            TAG="${GITHUB_REF#refs/tags/}"
            echo "üè∑Ô∏è Processing tag: $TAG"
            echo "build=true" >> $GITHUB_OUTPUT

            if [[ "$TAG" == *"-beta."* ]]; then
              echo "‚úÖ Building (beta release - all platforms with notarization)"
            elif [[ "$TAG" == *"-test."* ]]; then
              echo "‚úÖ Building (test release - all platforms, skipping notarization)"
            else
              echo "‚úÖ Building (production tag - all platforms)"
            fi
          # For workflow_dispatch, check selective build settings
          elif [[ "${{ inputs.selective_build }}" != "true" ]]; then
            echo "build=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Building (selective build disabled - all platforms)"
          else
            # Selective build is enabled, check individual platform settings
            case "${{ matrix.platform_id }}" in
              macos_intel)
                if [[ "${{ inputs.build_macos_intel }}" == "true" ]]; then
                  echo "build=true" >> $GITHUB_OUTPUT
                  echo "‚úÖ Building macOS Intel (selected)"
                else
                  echo "build=false" >> $GITHUB_OUTPUT
                  echo "‚è≠Ô∏è Skipping macOS Intel (not selected)"
                fi
                ;;
              macos_arm)
                if [[ "${{ inputs.build_macos_arm }}" == "true" ]]; then
                  echo "build=true" >> $GITHUB_OUTPUT
                  echo "‚úÖ Building macOS ARM (selected)"
                else
                  echo "build=false" >> $GITHUB_OUTPUT
                  echo "‚è≠Ô∏è Skipping macOS ARM (not selected)"
                fi
                ;;
              linux_x64|linux_arm64)
                if [[ "${{ inputs.build_linux }}" == "true" ]]; then
                  echo "build=true" >> $GITHUB_OUTPUT
                  echo "‚úÖ Building Linux ${{ matrix.arch }} (selected)"
                else
                  echo "build=false" >> $GITHUB_OUTPUT
                  echo "‚è≠Ô∏è Skipping Linux ${{ matrix.arch }} (not selected)"
                fi
                ;;
              windows)
                if [[ "${{ inputs.build_windows }}" == "true" ]]; then
                  echo "build=true" >> $GITHUB_OUTPUT
                  echo "‚úÖ Building Windows (selected)"
                else
                  echo "build=false" >> $GITHUB_OUTPUT
                  echo "‚è≠Ô∏è Skipping Windows (not selected)"
                fi
                ;;
            esac
          fi
        shell: bash
      
      # Skip this job if platform is not selected
      - name: Skip Job if Platform Not Selected
        if: steps.should_build.outputs.build == 'false'
        run: |
          echo "Platform not selected for build, exiting successfully"
          exit 0
        shell: bash
      
      - uses: actions/checkout@v4
        if: steps.should_build.outputs.build == 'true'
      
      # Setup Apple certificate for macOS signing
      - name: Setup Apple Certificate
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        uses: ./.github/actions/apple-certificates
        with:
          certificate-p12: ${{ secrets.APPLE_CERTIFICATE_P12 }}
          certificate-password: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          operation: setup
      
      - name: Setup Node
        if: steps.should_build.outputs.build == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: 'npm'
      
      - name: Install Rust stable
        if: steps.should_build.outputs.build == 'true'
        uses: dtolnay/rust-toolchain@87f07835889b686aca1fb3733c2aa2d61586c1e1
        with:
          toolchain: stable
          targets: ${{ matrix.arch == 'intel' && 'x86_64-apple-darwin' || matrix.arch == 'apple-silicon' && 'aarch64-apple-darwin' || matrix.arch == 'x64' && contains(matrix.platform, 'ubuntu') && 'x86_64-unknown-linux-gnu' || matrix.arch == 'arm64' && contains(matrix.platform, 'ubuntu') && 'aarch64-unknown-linux-gnu' || matrix.platform == 'windows-latest' && 'x86_64-pc-windows-msvc' }}
      
      - name: Rust cache
        if: steps.should_build.outputs.build == 'true'
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Run sccache
        if: steps.should_build.outputs.build == 'true'
        uses: mozilla-actions/sccache-action@v0.0.7

      - name: Install dependencies (Ubuntu only)
        if: contains(matrix.platform, 'ubuntu') && steps.should_build.outputs.build == 'true'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libayatana-appindicator3-dev librsvg2-dev patchelf xdg-utils
          sudo apt-get install -y libwebkit2gtk-4.0-dev || true
          sudo apt-get install -y rpm
          sudo apt-get install -y libpcsclite-dev swig
      
      - name: Install frontend dependencies
        if: steps.should_build.outputs.build == 'true'
        run: npm install --prefix src-ui

      # Binary dependencies - fetch from GitHub Release
      - name: Cache Binary Dependencies
        if: steps.should_build.outputs.build == 'true'
        uses: actions/cache@v4
        with:
          path: src-tauri/bin/
          key: binaries-${{ runner.os }}-${{ matrix.platform_id }}-${{ hashFiles('src-tauri/bin/binary-dependencies.json') }}
          # No restore-keys - force fresh download when checksums change

      - name: Fetch Binary Dependencies
        if: steps.should_build.outputs.build == 'true'
        run: |
          chmod +x scripts/cicd/fetch-binaries.sh
          ./scripts/cicd/fetch-binaries.sh
        shell: bash

      - name: Verify Binary Dependencies
        if: steps.should_build.outputs.build == 'true'
        run: |
          # Verify binaries were downloaded
          echo "Verifying binaries for ${{ matrix.platform }}..."

          if [[ "${{ matrix.platform }}" == "macos-latest" ]]; then
            PLATFORM_DIR="darwin"
          elif [[ "${{ matrix.platform }}" == *"ubuntu"* ]]; then
            PLATFORM_DIR="linux"
          else
            PLATFORM_DIR="windows"
          fi

          # Check required binaries exist (handle .exe extension on Windows)
          for binary in age age-plugin-yubikey ykman; do
            if [ "$PLATFORM_DIR" = "windows" ]; then
              # On Windows, check for .exe files
              if [ ! -e "src-tauri/bin/$PLATFORM_DIR/${binary}.exe" ] && [ ! -e "src-tauri/bin/$PLATFORM_DIR/${binary}.bat" ]; then
                echo "‚ùå ERROR: Binary not found: ${binary}.exe or ${binary}.bat"
                exit 1
              fi
            else
              # On Unix platforms, check without extension
              if [ ! -e "src-tauri/bin/$PLATFORM_DIR/$binary" ]; then
                echo "‚ùå ERROR: Binary not found: $binary"
                exit 1
              fi
            fi
          done

          # Check ykman-bundle exists
          if [ ! -d "src-tauri/bin/$PLATFORM_DIR/ykman-bundle" ]; then
            echo "‚ùå ERROR: ykman-bundle directory not found"
            exit 1
          fi

          echo "‚úÖ All binaries verified for $PLATFORM_DIR"
        shell: bash

      - name: Build with Tauri
        if: steps.should_build.outputs.build == 'true'
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_DEVELOPER_ID }}
          SCCACHE_GHA_ENABLED: "true"
          RUSTC_WRAPPER: "sccache"
        with:
          # For macOS: Build only .app (we'll create DMG after signing)
          # For Linux/Windows: Build all bundles normally
          args: ${{ matrix.platform == 'macos-latest' && format('{0} --bundles app', matrix.args) || matrix.args }}

      # Diagnostic: Check code signing identities available
      - name: Verify Code Signing Identity (macOS)
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        shell: bash
        run: |
          echo "üîé Listing code signing identities on runner:"
          security find-identity -v -p codesigning || true

      # Fix Tauri bug that dereferences Python.framework symlinks
      - name: Restore Python.framework Symlinks (Fix Tauri Bug #13219)
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        shell: bash
        run: |
          echo "üîß Restoring Python.framework symlinks broken by Tauri bundler..."

          # Locate the built .app
          if [ "${{ matrix.arch }}" = "intel" ]; then
            APP_DIR="target/x86_64-apple-darwin/release/bundle/macos"
          else
            APP_DIR="target/aarch64-apple-darwin/release/bundle/macos"
          fi

          APP_PATH=$(find "$APP_DIR" -maxdepth 1 -name "*.app" -type d | head -1)
          FW="$APP_PATH/Contents/Resources/bin/darwin/ykman-bundle/_internal/Python.framework"

          if [ -d "$FW" ]; then
            echo "Framework path: $FW"

            # Check current state
            echo "Before fix:"
            ls -la "$FW/" | grep -E "Python|Resources"

            cd "$FW"

            # Remove dereferenced files that Tauri created
            if [ -f "Python" ] && [ ! -L "Python" ]; then
              echo "Removing dereferenced Python file ($(du -h Python | cut -f1))"
              rm -f Python
            fi

            if [ -d "Resources" ] && [ ! -L "Resources" ]; then
              echo "Removing dereferenced Resources directory"
              rm -rf Resources
            fi

            # Restore Versions/Current symlink (critical for framework structure)
            if [ ! -L "Versions/Current" ]; then
              echo "Restoring Versions/Current ‚Üí 3.12 symlink..."
              cd Versions
              rm -rf Current 2>/dev/null || true  # Remove if dereferenced
              ln -s 3.12 Current
              cd ..  # Go back to framework root
            fi

            # Recreate proper symlinks at top level
            echo "Creating top-level symlinks..."
            ln -s Versions/Current/Python Python
            ln -s Versions/Current/Resources Resources

            # Remove stale _CodeSignature directory (becomes invalid after symlink restoration)
            if [ -d "_CodeSignature" ]; then
              echo "Removing stale _CodeSignature from framework root..."
              rm -rf _CodeSignature
            fi

            # Verify all symlinks restored
            echo "After fix:"
            ls -la | grep -E "Python|Resources"
            echo "Versions/Current:"
            ls -la Versions/ | grep Current

            echo "‚úÖ Python.framework symlinks restored (3 symlinks, cleaned signatures)"
          else
            echo "‚ö†Ô∏è Python.framework not found, skipping symlink restoration"
          fi

      # Post-build: Sign all Mach-O files inside the .app bundle
      - name: Sign Bundled Binaries Inside .app (macOS)
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        id: sign-app
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_DEVELOPER_ID }}
        shell: bash
        run: |
          set -euo pipefail
          set -o pipefail
          echo "üîê Post-build signing: all Mach-O files inside .app bundle..."

          # Locate the built .app
          if [ "${{ matrix.arch }}" = "intel" ]; then
            APP_DIR="target/x86_64-apple-darwin/release/bundle/macos"
          else
            APP_DIR="target/aarch64-apple-darwin/release/bundle/macos"
          fi

          APP_PATH=$(find "$APP_DIR" -maxdepth 1 -name "*.app" -type d | head -1)
          echo "Found app: $APP_PATH"
          echo "app-path=$APP_PATH" >> $GITHUB_OUTPUT

          if [ ! -d "$APP_PATH" ]; then
            echo "‚ùå ERROR: .app bundle not found!"
            exit 1
          fi

          # Clear quarantine attributes
          xattr -r -d com.apple.quarantine "$APP_PATH" 2>/dev/null || true

          # Critical: Framework signing order matters!
          # Python.framework must be EXCLUDED from generic loop, then signed last
          FW="$APP_PATH/Contents/Resources/bin/darwin/ykman-bundle/_internal/Python.framework"

          # Define paths upfront
          PY="$APP_PATH/Contents/Resources/bin/darwin/ykman-bundle/_internal/Python"

          # Step 1: Sign ALL Mach-O files EXCEPT Python.framework subtree
          echo "Step 1: Signing all Mach-O files (excluding Python.framework)..."
          SIGNED_COUNT=0
          /usr/bin/find "$APP_PATH" \
            \( -path "*/Python.framework" -o -path "*/Python.framework/*" -o -path "*/_internal/Python" \) -prune -o \
            -type f -print0 | while IFS= read -r -d '' file; do
            if file "$file" | grep -q "Mach-O"; then
              /usr/bin/codesign --force --sign "$APPLE_SIGNING_IDENTITY" --options runtime --timestamp "$file"
              SIGNED_COUNT=$((SIGNED_COUNT + 1))
              # Show progress every 10 files
              if [ $((SIGNED_COUNT % 10)) -eq 0 ]; then
                echo "  Progress: Signed $SIGNED_COUNT files..."
              fi
            fi
          done

          echo "‚úÖ Signed all Mach-O files (framework excluded)"

          # Step 1b: Handle _internal/Python explicitly (can be real file or symlink)
          echo "Step 1b: Handling _internal/Python..."
          if [ -e "$PY" ] && [ ! -L "$PY" ] && file "$PY" | grep -q "Mach-O"; then
            echo "Signing standalone Python binary (real file): $PY"
            chmod u+w "$PY" 2>/dev/null || true
            /usr/bin/codesign --remove-signature "$PY" 2>/dev/null || true
            /usr/bin/codesign --force --sign "$APPLE_SIGNING_IDENTITY" --options runtime --timestamp "$PY"
          elif [ -L "$PY" ]; then
            echo "Note: $PY is a symlink (covered by framework signing)"
          fi

          # Step 2: Sign Python.framework properly (inner binary first, then framework)
          echo "Step 2: Signing Python.framework with proper framework rules..."
          if [ -d "$FW" ]; then
            # Detect current version (usually 3.12 for PyInstaller)
            CUR_VER=$(/usr/bin/readlink "$FW/Versions/Current" 2>/dev/null || echo "3.12")
            PYINNER="$FW/Versions/$CUR_VER/Python"

            echo "Framework path: $FW"
            echo "Inner binary: $PYINNER"

            # Make writable
            chmod -R u+w "$FW" 2>/dev/null || true

            # Remove any existing signatures (clean slate)
            /usr/bin/codesign --remove-signature "$PYINNER" 2>/dev/null || true
            /usr/bin/codesign --remove-signature "$FW" 2>/dev/null || true

            # Sign inner binary FIRST (the real Mach-O, not the symlink)
            echo "Step 2a: Signing framework inner binary: $PYINNER"
            /usr/bin/codesign --force --sign "$APPLE_SIGNING_IDENTITY" --options runtime --timestamp "$PYINNER"

            # Verify inner binary immediately
            echo "Verifying inner binary signature..."
            /usr/bin/codesign --verify --strict --verbose=6 "$PYINNER"

            # Sign framework directory LAST (this seals it with CodeResources)
            echo "Step 2b: Signing framework directory: $FW"
            /usr/bin/codesign --force --sign "$APPLE_SIGNING_IDENTITY" --options runtime --timestamp "$FW"

            # Verify framework seal
            echo "Verifying framework signature..."
            /usr/bin/codesign --verify --strict --verbose=6 "$FW"

            # Show signature details for debugging
            echo "Framework signature details:"
            /usr/bin/codesign -dv --verbose=4 "$FW" 2>&1 | grep -E "Authority|TeamIdentifier|Timestamp" || true
          fi

          # Step 4: Sign .app bundle itself last (NO --deep - everything already signed)
          echo "Step 4: Signing .app bundle wrapper (without --deep)..."
          /usr/bin/codesign --force --sign "$APPLE_SIGNING_IDENTITY" --options runtime --timestamp "$APP_PATH"

          # Step 5: Verify signatures on problem areas
          echo "Step 5: Verifying all framework components..."
          if [ -d "$FW" ]; then
            echo "Checking framework symlinks and inner binary..."
            ls -la "$FW/Python" || true
            ls -la "$FW/Versions/Current" || true
            [ -e "$FW/Python" ] && /usr/bin/codesign -dv --verbose=4 "$FW/Python" 2>&1 | grep -E "Authority|Timestamp" || true
            [ -e "$PYINNER" ] && /usr/bin/codesign -dv --verbose=4 "$PYINNER" 2>&1 | grep -E "Authority|Timestamp" || true
          fi

          # Step 6: Verify complete app and assess with Gatekeeper
          echo "Step 6: Final verification..."
          /usr/bin/codesign --verify --strict --verbose=6 "$APP_PATH"

          echo "Step 6b: Gatekeeper assessment..."
          set +e
          SPCTL_OUTPUT=$(/usr/sbin/spctl --assess --type execute --verbose=4 "$APP_PATH" 2>&1)
          SPCTL_STATUS=$?
          set -e
          echo "$SPCTL_OUTPUT"
          if [ "$SPCTL_STATUS" -ne 0 ]; then
            if echo "$SPCTL_OUTPUT" | grep -q "source=Unnotarized Developer ID"; then
              echo "‚ö†Ô∏è Gatekeeper reports bundle is not yet notarized (expected before notarization)."
            else
              echo "‚ùå Gatekeeper assessment failed with unexpected error"
              exit "$SPCTL_STATUS"
            fi
          else
            echo "‚úÖ Gatekeeper assessment passed"
          fi

          echo "üéâ All signing complete and verified"

      # Diagnostic: Verify specific problem files are signed
      - name: Inspect Problem Files (macOS)
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        shell: bash
        run: |
          APP="${{ steps.sign-app.outputs.app-path }}"
          AGE="$APP/Contents/Resources/bin/darwin/age"
          SCARD="$APP/Contents/Resources/bin/darwin/ykman-bundle/_internal/smartcard/scard/_scard.cpython-312-darwin.so"

          echo "üîç Inspecting signatures on problem files..."
          for f in "$AGE" "$SCARD"; do
            if [ -f "$f" ]; then
              echo "‚îÅ‚îÅ‚îÅ $f ‚îÅ‚îÅ‚îÅ"
              file "$f" || true
              echo "Signature details:"
              codesign -dv --verbose=4 "$f" 2>&1 | grep -E "Authority|Timestamp|Runtime" || echo "‚ö†Ô∏è Missing signature info"
              echo ""
            else
              echo "‚ö†Ô∏è File not found: $f"
            fi
          done

      # Create DMG from signed .app bundle
      - name: Create DMG from Signed App (macOS)
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        shell: bash
        run: |
          echo "üì¶ Creating DMG from signed .app bundle..."

          # Locate the signed .app
          if [ "${{ matrix.arch }}" = "intel" ]; then
            APP_DIR="target/x86_64-apple-darwin/release/bundle/macos"
          else
            APP_DIR="target/aarch64-apple-darwin/release/bundle/macos"
          fi

          APP_PATH=$(find "$APP_DIR" -maxdepth 1 -name "*.app" -type d | head -1)
          APP_NAME=$(basename "$APP_PATH")

          # Create DMG output directory
          DMG_DIR="$(dirname "$APP_DIR")/dmg"
          mkdir -p "$DMG_DIR"

          # DMG filename
          if [ "${{ matrix.arch }}" = "intel" ]; then
            DMG_NAME="Barqly Vault_0.2.0_x64.dmg"
          else
            DMG_NAME="Barqly Vault_0.2.0_aarch64.dmg"
          fi

          DMG_PATH="$DMG_DIR/$DMG_NAME"

          # Verify framework signature BEFORE DMG creation
          echo "üîç Verifying framework signature before DMG creation..."
          FW_CHECK="$APP_PATH/Contents/Resources/bin/darwin/ykman-bundle/_internal/Python.framework"
          if [ -d "$FW_CHECK" ]; then
            /usr/bin/codesign --verify --strict --verbose=2 "$FW_CHECK" || {
              echo "‚ùå Framework signature invalid before DMG creation!"
              exit 1
            }
            echo "‚úÖ Framework signature valid before DMG"
          fi

          # DIAGNOSTIC: Check framework structure BEFORE DMG creation
          echo ""
          echo "=== BEFORE DMG: Framework structure check ==="
          FRAMEWORK_PATH="$APP_PATH/Contents/Resources/bin/darwin/ykman-bundle/_internal/Python.framework"
          ls -la "$FRAMEWORK_PATH/" | head -10
          echo "Checking if Python is a symlink:"
          if [ -L "$FRAMEWORK_PATH/Python" ]; then
            echo "‚úì Python is a symlink pointing to: $(readlink "$FRAMEWORK_PATH/Python")"
          else
            echo "‚ö†Ô∏è Python is NOT a symlink!"
            file "$FRAMEWORK_PATH/Python"
          fi
          echo "Checking if Resources is a symlink:"
          if [ -L "$FRAMEWORK_PATH/Resources" ]; then
            echo "‚úì Resources is a symlink pointing to: $(readlink "$FRAMEWORK_PATH/Resources")"
          else
            echo "‚ö†Ô∏è Resources is NOT a symlink!"
          fi
          echo ""

          # Create DMG from the signed .app
          echo "Creating DMG: $DMG_PATH"

          # CRITICAL: Alternative DMG creation to preserve framework structure
          # The issue is that hdiutil create -srcfolder corrupts the Python.framework
          # Solution: Create empty DMG, mount it, copy with ditto, then convert

          echo "üîß Using alternative DMG creation method to preserve framework..."

          # Remove extended attributes first (still important)
          echo "Removing extended attributes from signed app..."
          /usr/bin/xattr -cr "$APP_PATH" || true

          # Create a temporary sparse image (more efficient than fixed size)
          TEMP_DMG="$RUNNER_TEMP/temp_sparse.dmg"
          echo "Creating temporary sparse DMG..."
          hdiutil create -size 500m -fs HFS+ -volname "Barqly Vault" -type SPARSE "$TEMP_DMG"

          # Mount the temporary DMG
          MOUNT_POINT="$RUNNER_TEMP/dmg_mount"
          mkdir -p "$MOUNT_POINT"
          echo "Mounting temporary DMG at: $MOUNT_POINT"
          hdiutil attach "${TEMP_DMG}.sparseimage" -mountpoint "$MOUNT_POINT" -nobrowse -noverify -noautoopen

          # Copy app using ditto (preserves everything correctly including symlinks)
          echo "Copying app with ditto to preserve structure..."
          /usr/bin/ditto -v "$APP_PATH" "$MOUNT_POINT/$(basename "$APP_PATH")"

          # Unmount the temporary DMG
          echo "Unmounting temporary DMG..."
          hdiutil detach "$MOUNT_POINT" -force

          # Convert sparse image to compressed DMG
          echo "Converting to final compressed DMG..."
          hdiutil convert "${TEMP_DMG}.sparseimage" -format UDZO -o "$DMG_PATH" -ov

          # Clean up
          rm -f "${TEMP_DMG}.sparseimage"
          rm -rf "$MOUNT_POINT"

          echo "‚úÖ DMG created: $DMG_PATH"
          ls -lh "$DMG_PATH"

      # Verify binaries in bundled artifacts (Post-Bundle Verification)
      - name: Find DMG Path
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        id: find-dmg
        run: |
          if [ "${{ matrix.arch }}" = "intel" ]; then
            DMG_DIR="${{ github.workspace }}/target/x86_64-apple-darwin/release/bundle/dmg"
          else
            DMG_DIR="${{ github.workspace }}/target/aarch64-apple-darwin/release/bundle/dmg"
          fi
          DMG_PATH=$(find "$DMG_DIR" -name "*.dmg" -type f | head -1)
          echo "dmg-path=$DMG_PATH" >> $GITHUB_OUTPUT
        shell: bash
      
      - name: Notarize macOS DMG
        if: |
          matrix.platform == 'macos-latest' &&
          steps.should_build.outputs.build == 'true' &&
          !contains(github.ref, '-test.')
        uses: ./.github/actions/notarize-macos
        with:
          dmg-path: ${{ steps.find-dmg.outputs.dmg-path }}
          api-key: ${{ secrets.APPLE_API_KEY }}
          api-key-id: ${{ secrets.APPLE_API_KEY_ID }}
          api-issuer-id: ${{ secrets.APPLE_API_ISSUER_ID }}
      
      # Extract version from tag or input
      - name: Extract Version
        if: steps.should_build.outputs.build == 'true'
        id: version
        run: |
          if [[ "$GITHUB_REF" =~ refs/tags/v?(.+) ]]; then
            VERSION="${BASH_REMATCH[1]}"
          elif [[ -n "${{ github.event.inputs.version }}" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="dev"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
        shell: bash
      
      # Rename artifacts with consistent naming
      - name: Rename Artifacts
        if: steps.should_build.outputs.build == 'true'
        uses: ./.github/actions/rename-artifacts
        with:
          platform: ${{ matrix.platform }}
          arch: ${{ matrix.arch }}
          version: ${{ steps.version.outputs.version }}
      
      # Upload renamed artifacts
      - name: Upload artifacts
        if: steps.should_build.outputs.build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: barqly-vault-${{ matrix.platform }}-${{ matrix.arch }}
          path: renamed-artifacts/*
          retention-days: 7
      
      # Cleanup Apple keychain
      - name: Cleanup Apple Keychain
        if: always() && matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        uses: ./.github/actions/apple-certificates
        with:
          operation: cleanup

  # Create beta release with all artifacts
  create-beta-release:
    name: Create Beta Release
    needs: [publish-tauri]
    if: |
      always() && 
      github.event.inputs.promote_from == '' &&
      (needs.publish-tauri.result == 'success' || inputs.release_only == true) &&
      (startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Extract version
        id: get_version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION=${GITHUB_REF#refs/tags/v}
          fi
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "üì¶ Creating release for version: $VERSION"
      
      # Download all artifacts from build job
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        if: inputs.release_only != true
        with:
          path: release-artifacts
      
      # Download artifacts from previous run when release_only
      - name: Download artifacts from previous run
        if: inputs.release_only == true
        run: |
          echo "üîç Finding the most recent successful build for v${{ steps.get_version.outputs.VERSION }}..."
          
          RUN_ID=$(gh run list \
            --workflow=release.yml \
            --branch="v${{ steps.get_version.outputs.VERSION }}" \
            --status=completed \
            --limit=10 \
            --json databaseId,conclusion \
            --jq '.[] | select(.conclusion == "success" or .conclusion == "failure") | .databaseId' | head -1)
          
          if [ -z "$RUN_ID" ]; then
            echo "‚ùå No previous runs found for v${{ steps.get_version.outputs.VERSION }}"
            exit 1
          fi
          
          echo "üì• Downloading artifacts from run $RUN_ID..."
          mkdir -p release-artifacts
          gh run download $RUN_ID --dir release-artifacts
          echo "‚úÖ Downloaded artifacts from run $RUN_ID"
        env:
          GH_TOKEN: ${{ github.token }}
      
      - name: Prepare release assets
        run: |
          mkdir -p release-assets
          
          # Move all artifacts to release-assets, flattening structure
          find release-artifacts -type f \( \
            -name "*.dmg" -o \
            -name "*.exe" -o \
            -name "*.msi" -o \
            -name "*.deb" -o \
            -name "*.rpm" -o \
            -name "*.AppImage" -o \
            -name "*.tar.gz" -o \
            -name "*.zip" \
          \) -exec cp {} release-assets/ \;
          
          echo "üì¶ Final release assets:"
          ls -la release-assets/
      
      - name: Generate checksums
        uses: ./.github/actions/create-checksums
        with:
          artifacts-dir: release-assets
      
      # Clean up any existing release
      - name: Delete existing release if present
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          
          if gh release view "v$VERSION" &>/dev/null; then
            echo "‚ö†Ô∏è Found existing release for v$VERSION, deleting it..."
            gh release delete "v$VERSION" --yes
            echo "‚úÖ Existing release deleted"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Generate release notes
        continue-on-error: true  # Optional step - can be done manually
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          if [ -f "./scripts/cicd/generate-release-notes.sh" ]; then
            ./scripts/cicd/generate-release-notes.sh "$VERSION" > release-notes.md
          else
            echo "Script not found - create release notes manually"
            echo "# Barqly Vault v$VERSION" > release-notes.md
          fi
      
      - name: Create draft release
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          
          gh release create "v$VERSION" \
            --draft \
            --title "Barqly Vault v$VERSION" \
            --notes-file release-notes.md \
            release-assets/*
          
          echo "‚úÖ Beta release created for v$VERSION"
          echo "üìù Review and publish at: https://github.com/${{ github.repository }}/releases"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Automatically create production release draft when beta is created
  create-production-release:
    name: Create Production Release
    needs: [create-beta-release]
    if: |
      needs.create-beta-release.result == 'success' && 
      contains(github.ref, '-beta')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Extract version and create production version
        id: get_version
        run: |
          # Get the beta version from tag
          BETA_VERSION=${GITHUB_REF#refs/tags/v}
          echo "BETA_VERSION=$BETA_VERSION" >> $GITHUB_OUTPUT
          
          # Extract production version from beta.N format (e.g., 1.0.0-beta.3 -> 1.0.0)
          if [[ "$BETA_VERSION" =~ ^([0-9]+\.[0-9]+\.[0-9]+)-beta\.[0-9]+$ ]]; then
            PROD_VERSION="${BASH_REMATCH[1]}"
          else
            echo "‚ùå ERROR: Invalid beta version format. Expected format: X.Y.Z-beta.N"
            exit 1
          fi
          echo "PROD_VERSION=$PROD_VERSION" >> $GITHUB_OUTPUT
          
          echo "üì¶ Creating production release draft for v$PROD_VERSION from beta v$BETA_VERSION"
      
      - name: Download beta release assets
        run: |
          # Download all assets from the beta release
          mkdir -p production-assets
          
          gh release download "v${{ steps.get_version.outputs.BETA_VERSION }}" \
            --dir production-assets \
            --repo ${{ github.repository }}
          
          echo "üì• Downloaded beta assets:"
          ls -la production-assets/
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Rename artifacts for production
        run: |
          cd production-assets
          
          BETA_VERSION="${{ steps.get_version.outputs.BETA_VERSION }}"
          PROD_VERSION="${{ steps.get_version.outputs.PROD_VERSION }}"
          
          echo "üìù Renaming artifacts from $BETA_VERSION to $PROD_VERSION..."
          
          # Rename all files that contain the beta version string
          for file in *; do
            if [[ "$file" == *"$BETA_VERSION"* ]]; then
              new_name="${file//$BETA_VERSION/$PROD_VERSION}"
              mv "$file" "$new_name"
              echo "  Renamed: $file ‚Üí $new_name"
            fi
          done
          
          # Regenerate checksums with new filenames
          if [ -f "checksums.txt" ]; then
            echo "üìù Regenerating checksums..."
            rm checksums.txt
            shasum -a 256 * > checksums.txt
            echo "‚úÖ Checksums regenerated"
          fi
          
          echo "üì¶ Final production artifacts:"
          ls -la
      
      - name: Create production tag
        run: |
          # Configure git identity for tagging
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "GitHub Actions"
          
          # Delete existing tag if it exists (from previous failed runs)
          git push origin --delete "v${{ steps.get_version.outputs.PROD_VERSION }}" 2>/dev/null || true
          
          # Create a production tag pointing to the same commit as beta
          git tag "v${{ steps.get_version.outputs.PROD_VERSION }}" -m "Production release from v${{ steps.get_version.outputs.BETA_VERSION }}"
          git push origin "v${{ steps.get_version.outputs.PROD_VERSION }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Generate production release notes
        continue-on-error: true  # Optional step - can be done manually
        run: |
          PROD_VERSION="${{ steps.get_version.outputs.PROD_VERSION }}"
          if [ -f "./scripts/cicd/generate-release-notes.sh" ]; then
            ./scripts/cicd/generate-release-notes.sh "$PROD_VERSION" > release-notes.md
          else
            echo "Script not found - create release notes manually"
            echo "# Barqly Vault v$PROD_VERSION" > release-notes.md
          fi
      
      - name: Create production draft release
        run: |
          PROD_VERSION="${{ steps.get_version.outputs.PROD_VERSION }}"
          
          gh release create "v$PROD_VERSION" \
            --draft \
            --title "Barqly Vault v$PROD_VERSION" \
            --notes-file release-notes.md \
            production-assets/*
          
          echo "‚úÖ Production draft release created for v$PROD_VERSION"
          echo "üìù Ready to publish at: https://github.com/${{ github.repository }}/releases"
          echo ""
          echo "‚ö†Ô∏è This is a DRAFT - manually publish when ready for production!"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
