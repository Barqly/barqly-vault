name: Release Pipeline

on:
  push:
    tags:
      - 'v*.*.*-beta.*'  # Beta releases: v1.0.0-beta.1, v1.0.0-beta.2, etc.
      - 'v*.*.*-test.*'  # Test builds: v1.0.0-test.1 (skips notarization, saves costs)
      # This ensures:
      # - Alpha tags (v*.*.*-alpha.*) don't trigger builds (checkpoints only)
      # - Production tags (v*.*.*) don't trigger builds (manual promotion only)
      # - Beta tags trigger full CI/CD with notarization
      # - Test tags trigger full CI/CD WITHOUT notarization (for testing)
  
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.0)'
        required: false
      promote_from:
        description: 'Beta version to promote (e.g., 1.0.0-beta.3) - leave empty for new build'
        required: false
      list_available_betas:
        description: 'List available beta releases for promotion (check this to see options)'
        type: boolean
        default: false
      prerelease:
        description: 'Mark as pre-release'
        type: boolean
        default: false
      release_only:
        description: 'Skip build and only create release from existing artifacts'
        required: false
        type: boolean
        default: false
      selective_build:
        description: 'Enable selective platform building (for testing)'
        type: boolean
        default: false
      build_macos_intel:
        description: 'Build macOS Intel (x86_64)'
        type: boolean
        default: true
      build_macos_arm:
        description: 'Build macOS ARM (Apple Silicon)'
        type: boolean
        default: false  # Temporarily disabled for testing
      build_linux:
        description: 'Build Linux'
        type: boolean
        default: false  # Temporarily disabled for testing
      build_windows:
        description: 'Build Windows'
        type: boolean
        default: false  # Temporarily disabled for testing

jobs:
  # List available beta releases for promotion
  list-betas:
    if: github.event.inputs.list_available_betas == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: List Available Beta Releases
        run: |
          echo "## üìã Available Beta Releases for Promotion" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Version | Created | Status | Assets |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|---------|---------|---------|" >> $GITHUB_STEP_SUMMARY
          
          # List all beta releases (published and draft)
          gh release list \
            --repo ${{ github.repository }} \
            --limit 20 \
            --json tagName,name,createdAt,isDraft \
            --jq '.[] | select(.tagName | test("-beta")) | [.tagName, .createdAt[:10], (if .isDraft then "Draft" else "Published" end)] | @csv' \
          | while IFS=',' read -r tag date status; do
            # Clean up CSV formatting
            tag=$(echo "$tag" | tr -d '"')
            date=$(echo "$date" | tr -d '"')
            status=$(echo "$status" | tr -d '"')
            
            # Count assets for this release
            asset_count=$(gh release view "$tag" --repo ${{ github.repository }} --json assets --jq '.assets | length' 2>/dev/null || echo "0")
            
            echo "| \`$tag\` | $date | $status | $asset_count |" >> $GITHUB_STEP_SUMMARY
          done
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Usage:** Re-run this workflow with \`promote_from\` set to one of the beta versions above." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Example:** \`promote_from: 1.0.0-beta.3\` and \`version: 1.0.0\`" >> $GITHUB_STEP_SUMMARY
        env:
          GH_TOKEN: ${{ github.token }}

  # Handle promotion workflow when promote_from is specified
  promote:
    if: github.event.inputs.promote_from != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      
      - name: Promote Release
        uses: ./.github/actions/promote-release
        with:
          source-version: ${{ github.event.inputs.promote_from }}
          target-version: ${{ github.event.inputs.version }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          draft: true
      
      - name: Summary
        run: |
          echo "## üéâ Release Promoted Successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **From**: v${{ github.event.inputs.promote_from }}" >> $GITHUB_STEP_SUMMARY
          echo "- **To**: v${{ github.event.inputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: Draft (ready for manual publish)" >> $GITHUB_STEP_SUMMARY

  # Main build and release workflow
  publish-tauri:
    # Skip if we're promoting or only creating a release
    if: github.event.inputs.promote_from == '' && inputs.release_only != true
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          # macOS Intel
          - platform: 'macos-latest'
            args: '--target x86_64-apple-darwin'
            arch: 'intel'
            label: 'macOS (Intel)'
            platform_id: 'macos_intel'
          
          # macOS Apple Silicon
          - platform: 'macos-latest'
            args: '--target aarch64-apple-darwin'
            arch: 'apple-silicon'
            label: 'macOS (Apple M-series)'
            platform_id: 'macos_arm'
          
          # Linux x64 - Standard Linux desktops (.deb, .rpm, .appimage, .tar.gz)
          - platform: 'ubuntu-22.04'
            args: '--target x86_64-unknown-linux-gnu'
            arch: 'x64'
            label: 'Linux'
            platform_id: 'linux'
          
          # Windows x64
          - platform: 'windows-latest'
            args: '--target x86_64-pc-windows-msvc'
            arch: 'x64'
            label: 'Windows'
            platform_id: 'windows'

    runs-on: ${{ matrix.platform }}
    
    steps:
      # Check if this platform should be built based on selective build settings
      - name: Check Platform Build Condition
        id: should_build
        run: |
          # For tag pushes, build all platforms (beta and test tags)
          if [[ "${{ github.event_name }}" == "push" ]]; then
            TAG="${GITHUB_REF#refs/tags/}"
            echo "üè∑Ô∏è Processing tag: $TAG"
            echo "build=true" >> $GITHUB_OUTPUT

            if [[ "$TAG" == *"-beta."* ]]; then
              echo "‚úÖ Building (beta release - all platforms with notarization)"
            elif [[ "$TAG" == *"-test."* ]]; then
              echo "‚úÖ Building (test release - all platforms, skipping notarization)"
            else
              echo "‚úÖ Building (production tag - all platforms)"
            fi
          # For workflow_dispatch, check selective build settings
          elif [[ "${{ inputs.selective_build }}" != "true" ]]; then
            echo "build=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Building (selective build disabled - all platforms)"
          else
            # Selective build is enabled, check individual platform settings
            case "${{ matrix.platform_id }}" in
              macos_intel)
                if [[ "${{ inputs.build_macos_intel }}" == "true" ]]; then
                  echo "build=true" >> $GITHUB_OUTPUT
                  echo "‚úÖ Building macOS Intel (selected)"
                else
                  echo "build=false" >> $GITHUB_OUTPUT
                  echo "‚è≠Ô∏è Skipping macOS Intel (not selected)"
                fi
                ;;
              macos_arm)
                if [[ "${{ inputs.build_macos_arm }}" == "true" ]]; then
                  echo "build=true" >> $GITHUB_OUTPUT
                  echo "‚úÖ Building macOS ARM (selected)"
                else
                  echo "build=false" >> $GITHUB_OUTPUT
                  echo "‚è≠Ô∏è Skipping macOS ARM (not selected)"
                fi
                ;;
              linux_x64|linux_arm64)
                if [[ "${{ inputs.build_linux }}" == "true" ]]; then
                  echo "build=true" >> $GITHUB_OUTPUT
                  echo "‚úÖ Building Linux ${{ matrix.arch }} (selected)"
                else
                  echo "build=false" >> $GITHUB_OUTPUT
                  echo "‚è≠Ô∏è Skipping Linux ${{ matrix.arch }} (not selected)"
                fi
                ;;
              windows)
                if [[ "${{ inputs.build_windows }}" == "true" ]]; then
                  echo "build=true" >> $GITHUB_OUTPUT
                  echo "‚úÖ Building Windows (selected)"
                else
                  echo "build=false" >> $GITHUB_OUTPUT
                  echo "‚è≠Ô∏è Skipping Windows (not selected)"
                fi
                ;;
            esac
          fi
        shell: bash
      
      # Skip this job if platform is not selected
      - name: Skip Job if Platform Not Selected
        if: steps.should_build.outputs.build == 'false'
        run: |
          echo "Platform not selected for build, exiting successfully"
          exit 0
        shell: bash
      
      - uses: actions/checkout@v4
        if: steps.should_build.outputs.build == 'true'
      
      # Setup Apple certificate for macOS signing
      - name: Setup Apple Certificate
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        uses: ./.github/actions/apple-certificates
        with:
          certificate-p12: ${{ secrets.APPLE_CERTIFICATE_P12 }}
          certificate-password: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          operation: setup
      
      - name: Setup Node
        if: steps.should_build.outputs.build == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: 'npm'
      
      - name: Install Rust stable
        if: steps.should_build.outputs.build == 'true'
        uses: dtolnay/rust-toolchain@87f07835889b686aca1fb3733c2aa2d61586c1e1
        with:
          toolchain: stable
          targets: ${{ matrix.arch == 'intel' && 'x86_64-apple-darwin' || matrix.arch == 'apple-silicon' && 'aarch64-apple-darwin' || matrix.arch == 'x64' && contains(matrix.platform, 'ubuntu') && 'x86_64-unknown-linux-gnu' || matrix.arch == 'arm64' && contains(matrix.platform, 'ubuntu') && 'aarch64-unknown-linux-gnu' || matrix.platform == 'windows-latest' && 'x86_64-pc-windows-msvc' }}
      
      - name: Rust cache
        if: steps.should_build.outputs.build == 'true'
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Run sccache
        if: steps.should_build.outputs.build == 'true'
        uses: mozilla-actions/sccache-action@v0.0.7

      - name: Install dependencies (Ubuntu only)
        if: contains(matrix.platform, 'ubuntu') && steps.should_build.outputs.build == 'true'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libayatana-appindicator3-dev librsvg2-dev patchelf xdg-utils
          sudo apt-get install -y libwebkit2gtk-4.0-dev || true
          sudo apt-get install -y rpm
          sudo apt-get install -y libpcsclite-dev swig
      
      - name: Install frontend dependencies
        if: steps.should_build.outputs.build == 'true'
        run: npm install --prefix src-ui

      # Binary dependencies - fetch from GitHub Release
      - name: Cache Binary Dependencies
        if: steps.should_build.outputs.build == 'true'
        uses: actions/cache@v4
        with:
          path: src-tauri/bin/
          key: binaries-${{ runner.os }}-${{ matrix.platform_id }}-${{ hashFiles('src-tauri/bin/binary-dependencies.json') }}
          restore-keys: |
            binaries-${{ runner.os }}-${{ matrix.platform_id }}-
            binaries-${{ runner.os }}-

      - name: Fetch Binary Dependencies
        if: steps.should_build.outputs.build == 'true'
        run: |
          chmod +x scripts/cicd/fetch-binaries.sh
          ./scripts/cicd/fetch-binaries.sh
        shell: bash

      - name: Verify Binary Dependencies
        if: steps.should_build.outputs.build == 'true'
        run: |
          # Verify binaries were downloaded
          echo "Verifying binaries for ${{ matrix.platform }}..."

          if [[ "${{ matrix.platform }}" == "macos-latest" ]]; then
            PLATFORM_DIR="darwin"
          elif [[ "${{ matrix.platform }}" == *"ubuntu"* ]]; then
            PLATFORM_DIR="linux"
          else
            PLATFORM_DIR="windows"
          fi

          # Check required binaries exist (handle .exe extension on Windows)
          for binary in age age-plugin-yubikey ykman; do
            if [ "$PLATFORM_DIR" = "windows" ]; then
              # On Windows, check for .exe files
              if [ ! -e "src-tauri/bin/$PLATFORM_DIR/${binary}.exe" ] && [ ! -e "src-tauri/bin/$PLATFORM_DIR/${binary}.bat" ]; then
                echo "‚ùå ERROR: Binary not found: ${binary}.exe or ${binary}.bat"
                exit 1
              fi
            else
              # On Unix platforms, check without extension
              if [ ! -e "src-tauri/bin/$PLATFORM_DIR/$binary" ]; then
                echo "‚ùå ERROR: Binary not found: $binary"
                exit 1
              fi
            fi
          done

          # Check ykman-bundle exists
          if [ ! -d "src-tauri/bin/$PLATFORM_DIR/ykman-bundle" ]; then
            echo "‚ùå ERROR: ykman-bundle directory not found"
            exit 1
          fi

          echo "‚úÖ All binaries verified for $PLATFORM_DIR"
        shell: bash

      - name: Build with Tauri
        if: steps.should_build.outputs.build == 'true'
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_DEVELOPER_ID }}
          SCCACHE_GHA_ENABLED: "true"
          RUSTC_WRAPPER: "sccache"
        with:
          # For macOS: Build only .app (we'll create DMG after signing)
          # For Linux/Windows: Build all bundles normally
          args: ${{ matrix.platform == 'macos-latest' && format('{0} --bundles app', matrix.args) || matrix.args }}

      # Diagnostic: Check code signing identities available
      - name: Verify Code Signing Identity (macOS)
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        shell: bash
        run: |
          echo "üîé Listing code signing identities on runner:"
          security find-identity -v -p codesigning || true

      # Post-build: Sign .app bundle (ykman is pre-signed, just sign age/age-plugin and .app)
      - name: Sign App Bundle (macOS)
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        id: sign-app
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_DEVELOPER_ID }}
        shell: bash
        run: |
          set -euo pipefail
          echo "üîê Signing .app bundle (ykman is pre-signed from dependencies)..."

          # Locate the built .app
          if [ "${{ matrix.arch }}" = "intel" ]; then
            APP_DIR="target/x86_64-apple-darwin/release/bundle/macos"
          else
            APP_DIR="target/aarch64-apple-darwin/release/bundle/macos"
          fi

          APP_PATH=$(find "$APP_DIR" -maxdepth 1 -name "*.app" -type d | head -1)
          echo "Found app: $APP_PATH"
          echo "app-path=$APP_PATH" >> $GITHUB_OUTPUT

          if [ ! -d "$APP_PATH" ]; then
            echo "‚ùå ERROR: .app bundle not found!"
            exit 1
          fi

          # Clear quarantine attributes
          xattr -r -d com.apple.quarantine "$APP_PATH" 2>/dev/null || true

          # Sign our own binaries (age, age-plugin-yubikey)
          # NOTE: ykman-bundle is already signed in dependencies release - DO NOT re-sign
          echo "Signing our binaries (age, age-plugin-yubikey)..."
          AGE_BIN="$APP_PATH/Contents/Resources/bin/darwin/age"
          PLUGIN_BIN="$APP_PATH/Contents/Resources/bin/darwin/age-plugin-yubikey"

          if [ -f "$AGE_BIN" ]; then
            echo "Signing: $AGE_BIN"
            /usr/bin/codesign --force --sign "$APPLE_SIGNING_IDENTITY" --options runtime --timestamp "$AGE_BIN"
          fi

          if [ -f "$PLUGIN_BIN" ]; then
            echo "Signing: $PLUGIN_BIN"
            /usr/bin/codesign --force --sign "$APPLE_SIGNING_IDENTITY" --options runtime --timestamp "$PLUGIN_BIN"
          fi

          # Sign any other Mach-O files (excluding ykman-bundle which is pre-signed)
          echo "Signing remaining Mach-O files (excluding pre-signed ykman-bundle)..."
          /usr/bin/find "$APP_PATH" \
            -path "*/ykman-bundle" -prune -o \
            -path "*/ykman-bundle/*" -prune -o \
            -type f -print0 | while IFS= read -r -d '' file; do
            if file "$file" | grep -q "Mach-O"; then
              # Skip if already signed (age, age-plugin we just signed)
              if ! /usr/bin/codesign --verify "$file" 2>/dev/null; then
                /usr/bin/codesign --force --sign "$APPLE_SIGNING_IDENTITY" --options runtime --timestamp "$file"
              fi
            fi
          done

          # Sign the .app bundle itself (NO --deep - everything already signed)
          echo "Signing .app bundle..."
          /usr/bin/codesign --force --sign "$APPLE_SIGNING_IDENTITY" --options runtime --timestamp "$APP_PATH"

          # Verify final signature
          echo "üîç Verifying .app signature..."
          /usr/bin/codesign --verify --strict --verbose=2 "$APP_PATH"

          # Gatekeeper assessment
          echo "üîç Gatekeeper assessment..."
          set +e
          SPCTL_OUTPUT=$(/usr/sbin/spctl --assess --type execute --verbose=4 "$APP_PATH" 2>&1)
          SPCTL_STATUS=$?
          set -e
          echo "$SPCTL_OUTPUT"
          if [ "$SPCTL_STATUS" -ne 0 ]; then
            if echo "$SPCTL_OUTPUT" | grep -q "source=Unnotarized Developer ID"; then
              echo "‚ö†Ô∏è Not yet notarized (expected before notarization)"
            else
              echo "‚ùå Gatekeeper assessment failed"
              exit "$SPCTL_STATUS"
            fi
          fi

          echo "‚úÖ App bundle signed successfully"

      # Create DMG from signed .app bundle
      - name: Create DMG from Signed App (macOS)
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        shell: bash
        run: |
          echo "üì¶ Creating DMG from signed .app bundle..."

          # Locate the signed .app
          if [ "${{ matrix.arch }}" = "intel" ]; then
            APP_DIR="target/x86_64-apple-darwin/release/bundle/macos"
          else
            APP_DIR="target/aarch64-apple-darwin/release/bundle/macos"
          fi

          APP_PATH=$(find "$APP_DIR" -maxdepth 1 -name "*.app" -type d | head -1)
          APP_NAME=$(basename "$APP_PATH")

          # Create DMG output directory
          DMG_DIR="$(dirname "$APP_DIR")/dmg"
          mkdir -p "$DMG_DIR"

          # DMG filename
          if [ "${{ matrix.arch }}" = "intel" ]; then
            DMG_NAME="Barqly Vault_0.2.0_x64.dmg"
          else
            DMG_NAME="Barqly Vault_0.2.0_aarch64.dmg"
          fi

          DMG_PATH="$DMG_DIR/$DMG_NAME"

          # Create DMG (simple, no framework concerns since ykman is pre-signed single binary)
          echo "Creating DMG: $DMG_PATH"

          # Remove extended attributes (best practice)
          echo "Removing extended attributes..."
          /usr/bin/xattr -cr "$APP_PATH" || true

          # Create DMG using standard method
          echo "Creating compressed DMG..."
          hdiutil create "$DMG_PATH" \
            -volname "Barqly Vault" \
            -fs HFS+ \
            -srcfolder "$APP_PATH" \
            -ov \
            -format UDZO

          echo "‚úÖ DMG created: $DMG_PATH"
          ls -lh "$DMG_PATH"

      # Find and notarize macOS DMG
      - name: Find DMG Path
        if: matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        id: find-dmg
        run: |
          if [ "${{ matrix.arch }}" = "intel" ]; then
            DMG_DIR="${{ github.workspace }}/target/x86_64-apple-darwin/release/bundle/dmg"
          else
            DMG_DIR="${{ github.workspace }}/target/aarch64-apple-darwin/release/bundle/dmg"
          fi
          DMG_PATH=$(find "$DMG_DIR" -name "*.dmg" -type f | head -1)
          echo "dmg-path=$DMG_PATH" >> $GITHUB_OUTPUT
        shell: bash
      
      - name: Notarize macOS DMG
        if: |
          matrix.platform == 'macos-latest' &&
          steps.should_build.outputs.build == 'true' &&
          !contains(github.ref, '-test.')
        uses: ./.github/actions/notarize-macos
        with:
          dmg-path: ${{ steps.find-dmg.outputs.dmg-path }}
          api-key: ${{ secrets.APPLE_API_KEY }}
          api-key-id: ${{ secrets.APPLE_API_KEY_ID }}
          api-issuer-id: ${{ secrets.APPLE_API_ISSUER_ID }}
      
      # Extract version from tag or input
      - name: Extract Version
        if: steps.should_build.outputs.build == 'true'
        id: version
        run: |
          if [[ "$GITHUB_REF" =~ refs/tags/v?(.+) ]]; then
            VERSION="${BASH_REMATCH[1]}"
          elif [[ -n "${{ github.event.inputs.version }}" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="dev"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
        shell: bash
      
      # Rename artifacts with consistent naming
      - name: Rename Artifacts
        if: steps.should_build.outputs.build == 'true'
        uses: ./.github/actions/rename-artifacts
        with:
          platform: ${{ matrix.platform }}
          arch: ${{ matrix.arch }}
          version: ${{ steps.version.outputs.version }}
      
      # Upload renamed artifacts
      - name: Upload artifacts
        if: steps.should_build.outputs.build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: barqly-vault-${{ matrix.platform }}-${{ matrix.arch }}
          path: renamed-artifacts/*
          retention-days: 7
      
      # Cleanup Apple keychain
      - name: Cleanup Apple Keychain
        if: always() && matrix.platform == 'macos-latest' && steps.should_build.outputs.build == 'true'
        uses: ./.github/actions/apple-certificates
        with:
          operation: cleanup

  # Create beta release with all artifacts
  create-beta-release:
    name: Create Beta Release
    needs: [publish-tauri]
    if: |
      always() && 
      github.event.inputs.promote_from == '' &&
      (needs.publish-tauri.result == 'success' || inputs.release_only == true) &&
      (startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Extract version
        id: get_version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION=${GITHUB_REF#refs/tags/v}
          fi
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "üì¶ Creating release for version: $VERSION"
      
      # Download all artifacts from build job
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        if: inputs.release_only != true
        with:
          path: release-artifacts
      
      # Download artifacts from previous run when release_only
      - name: Download artifacts from previous run
        if: inputs.release_only == true
        run: |
          echo "üîç Finding the most recent successful build for v${{ steps.get_version.outputs.VERSION }}..."
          
          RUN_ID=$(gh run list \
            --workflow=release.yml \
            --branch="v${{ steps.get_version.outputs.VERSION }}" \
            --status=completed \
            --limit=10 \
            --json databaseId,conclusion \
            --jq '.[] | select(.conclusion == "success" or .conclusion == "failure") | .databaseId' | head -1)
          
          if [ -z "$RUN_ID" ]; then
            echo "‚ùå No previous runs found for v${{ steps.get_version.outputs.VERSION }}"
            exit 1
          fi
          
          echo "üì• Downloading artifacts from run $RUN_ID..."
          mkdir -p release-artifacts
          gh run download $RUN_ID --dir release-artifacts
          echo "‚úÖ Downloaded artifacts from run $RUN_ID"
        env:
          GH_TOKEN: ${{ github.token }}
      
      - name: Prepare release assets
        run: |
          mkdir -p release-assets
          
          # Move all artifacts to release-assets, flattening structure
          find release-artifacts -type f \( \
            -name "*.dmg" -o \
            -name "*.exe" -o \
            -name "*.msi" -o \
            -name "*.deb" -o \
            -name "*.rpm" -o \
            -name "*.AppImage" -o \
            -name "*.tar.gz" -o \
            -name "*.zip" \
          \) -exec cp {} release-assets/ \;
          
          echo "üì¶ Final release assets:"
          ls -la release-assets/
      
      - name: Generate checksums
        uses: ./.github/actions/create-checksums
        with:
          artifacts-dir: release-assets
      
      # Clean up any existing release
      - name: Delete existing release if present
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          
          if gh release view "v$VERSION" &>/dev/null; then
            echo "‚ö†Ô∏è Found existing release for v$VERSION, deleting it..."
            gh release delete "v$VERSION" --yes
            echo "‚úÖ Existing release deleted"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Generate release notes
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          ./scripts/cicd/generate-release-notes.sh "$VERSION" > release-notes.md
      
      - name: Create draft release
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          
          gh release create "v$VERSION" \
            --draft \
            --title "Barqly Vault v$VERSION" \
            --notes-file release-notes.md \
            release-assets/*
          
          echo "‚úÖ Beta release created for v$VERSION"
          echo "üìù Review and publish at: https://github.com/${{ github.repository }}/releases"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Automatically create production release draft when beta is created
  create-production-release:
    name: Create Production Release
    needs: [create-beta-release]
    if: |
      needs.create-beta-release.result == 'success' && 
      contains(github.ref, '-beta')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Extract version and create production version
        id: get_version
        run: |
          # Get the beta version from tag
          BETA_VERSION=${GITHUB_REF#refs/tags/v}
          echo "BETA_VERSION=$BETA_VERSION" >> $GITHUB_OUTPUT
          
          # Extract production version from beta.N format (e.g., 1.0.0-beta.3 -> 1.0.0)
          if [[ "$BETA_VERSION" =~ ^([0-9]+\.[0-9]+\.[0-9]+)-beta\.[0-9]+$ ]]; then
            PROD_VERSION="${BASH_REMATCH[1]}"
          else
            echo "‚ùå ERROR: Invalid beta version format. Expected format: X.Y.Z-beta.N"
            exit 1
          fi
          echo "PROD_VERSION=$PROD_VERSION" >> $GITHUB_OUTPUT
          
          echo "üì¶ Creating production release draft for v$PROD_VERSION from beta v$BETA_VERSION"
      
      - name: Download beta release assets
        run: |
          # Download all assets from the beta release
          mkdir -p production-assets
          
          gh release download "v${{ steps.get_version.outputs.BETA_VERSION }}" \
            --dir production-assets \
            --repo ${{ github.repository }}
          
          echo "üì• Downloaded beta assets:"
          ls -la production-assets/
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Rename artifacts for production
        run: |
          cd production-assets
          
          BETA_VERSION="${{ steps.get_version.outputs.BETA_VERSION }}"
          PROD_VERSION="${{ steps.get_version.outputs.PROD_VERSION }}"
          
          echo "üìù Renaming artifacts from $BETA_VERSION to $PROD_VERSION..."
          
          # Rename all files that contain the beta version string
          for file in *; do
            if [[ "$file" == *"$BETA_VERSION"* ]]; then
              new_name="${file//$BETA_VERSION/$PROD_VERSION}"
              mv "$file" "$new_name"
              echo "  Renamed: $file ‚Üí $new_name"
            fi
          done
          
          # Regenerate checksums with new filenames
          if [ -f "checksums.txt" ]; then
            echo "üìù Regenerating checksums..."
            rm checksums.txt
            shasum -a 256 * > checksums.txt
            echo "‚úÖ Checksums regenerated"
          fi
          
          echo "üì¶ Final production artifacts:"
          ls -la
      
      - name: Create production tag
        run: |
          # Configure git identity for tagging
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "GitHub Actions"
          
          # Delete existing tag if it exists (from previous failed runs)
          git push origin --delete "v${{ steps.get_version.outputs.PROD_VERSION }}" 2>/dev/null || true
          
          # Create a production tag pointing to the same commit as beta
          git tag "v${{ steps.get_version.outputs.PROD_VERSION }}" -m "Production release from v${{ steps.get_version.outputs.BETA_VERSION }}"
          git push origin "v${{ steps.get_version.outputs.PROD_VERSION }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Generate production release notes
        run: |
          PROD_VERSION="${{ steps.get_version.outputs.PROD_VERSION }}"
          ./scripts/cicd/generate-release-notes.sh "$PROD_VERSION" > release-notes.md
      
      - name: Create production draft release
        run: |
          PROD_VERSION="${{ steps.get_version.outputs.PROD_VERSION }}"
          
          gh release create "v$PROD_VERSION" \
            --draft \
            --title "Barqly Vault v$PROD_VERSION" \
            --notes-file release-notes.md \
            production-assets/*
          
          echo "‚úÖ Production draft release created for v$PROD_VERSION"
          echo "üìù Ready to publish at: https://github.com/${{ github.repository }}/releases"
          echo ""
          echo "‚ö†Ô∏è This is a DRAFT - manually publish when ready for production!"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
