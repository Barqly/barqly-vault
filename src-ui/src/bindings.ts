// This file is auto-generated by tauri-specta. Do not edit manually.
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async generateKey(input: GenerateKeyInput) : Promise<Result<GenerateKeyResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("generate_key", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async validatePassphrase(input: ValidatePassphraseInput) : Promise<Result<ValidatePassphraseResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("validate_passphrase", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async verifyKeyPassphrase(input: VerifyKeyPassphraseInput) : Promise<Result<VerifyKeyPassphraseResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("verify_key_passphrase", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async validatePassphraseStrength(passphrase: string) : Promise<Result<PassphraseValidationResult, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("validate_passphrase_strength", { passphrase }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Encrypt files with progress streaming - delegates to service layer
 */
async encryptFiles(input: EncryptDataInput) : Promise<Result<string, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("encrypt_files", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Encrypt files with multiple keys (vault) - delegates to service layer
 */
async encryptFilesMulti(input: EncryptFilesMultiInput) : Promise<Result<EncryptFilesMultiResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("encrypt_files_multi", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get encryption operation status
 */
async getEncryptionStatus(input: GetEncryptionStatusInput) : Promise<Result<EncryptionStatusResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_encryption_status", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Decrypt files with progress streaming - delegates to DecryptionOrchestrationService
 */
async decryptData(input: DecryptDataInput) : Promise<Result<DecryptionResult, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("decrypt_data", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Verify a manifest file against extracted files
 */
async verifyManifest(input: VerifyManifestInput) : Promise<Result<VerifyManifestResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("verify_manifest", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get progress for a long-running operation
 */
async getProgress(input: GetProgressInput) : Promise<Result<GetProgressResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_progress", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Analyze encrypted vault file and return metadata for UI display
 * 
 * This command extracts vault metadata from the encrypted file path without
 * performing actual decryption. It's used by the Decrypt page to:
 * - Display vault name in PageHeader
 * - Show appropriate keys in dropdown
 * - Detect recovery mode scenarios
 */
async analyzeEncryptedVault(input: AnalyzeEncryptedVaultRequest) : Promise<Result<AnalyzeEncryptedVaultResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("analyze_encrypted_vault", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List keys with flexible filtering options - unified API
 */
async listUnifiedKeys(filter: KeyListFilter) : Promise<Result<GlobalKey[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_unified_keys", { filter }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Simple test command to verify the unified API works
 */
async testUnifiedKeys() : Promise<Result<string, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("test_unified_keys") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get all keys for a vault - wrapper around unified API
 */
async getVaultKeys(input: GetVaultKeysRequest) : Promise<Result<GetVaultKeysResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_vault_keys", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get structured key menu data for UI display
 */
async getKeyMenuData(input: GetKeyMenuDataRequest) : Promise<Result<GetKeyMenuDataResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_key_menu_data", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Remove a key from a vault - delegates to KeyRegistryService
 */
async removeKeyFromVault(input: RemoveKeyFromVaultRequest) : Promise<Result<RemoveKeyFromVaultResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_key_from_vault", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update a key's label - delegates to KeyRegistryService
 */
async updateKeyLabel(input: UpdateKeyLabelRequest) : Promise<Result<UpdateKeyLabelResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_key_label", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Deactivate a key (with optional immediate deletion)
 * 
 * This command has two modes:
 * 1. Normal deactivation (delete_immediately=false): Transitions key to Deactivated with 30-day grace period
 * 2. Immediate destruction (delete_immediately=true): Transitions key directly to Destroyed, deletes key file
 * 
 * For attached keys (Active state), both modes are available based on user choice.
 * This operation is idempotent - deactivating an already deactivated key returns success.
 */
async deactivateKey(request: DeactivateKeyRequest) : Promise<Result<DeactivateKeyResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("deactivate_key", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a key permanently (immediate destruction)
 * 
 * This command permanently deletes a key by:
 * 1. Updating registry status to Destroyed
 * 2. Deleting the key file from disk (for passphrase keys)
 * 
 * This is typically used for unattached keys (PreActivation state) that were never used.
 * For attached keys, consider using deactivateKey with delete_immediately flag.
 * 
 * IMPORTANT: This does NOT un-encrypt vaults. Any backups of the key file can still decrypt vaults.
 */
async deleteKey(request: DeleteKeyRequest) : Promise<Result<DeleteKeyResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_key", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Export a passphrase key file to a user-selected destination
 * 
 * This command copies the encrypted key file (.agekey.enc) from the app's keys directory
 * to a location chosen by the user (typically via file picker dialog in the frontend).
 * 
 * **Important:** This API assumes the key is a passphrase key. The frontend should only
 * show the Export button for passphrase keys, not YubiKey keys (which don't have .enc files).
 */
async exportKey(request: ExportKeyRequest) : Promise<Result<ExportKeyResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("export_key", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Restore a deactivated key
 * 
 * This command restores a deactivated key back to its previous state (Active or Suspended).
 * Only keys in Deactivated state can be restored, and only within 30 days of deactivation.
 * This operation is NOT idempotent - attempting to restore a non-deactivated key returns an error.
 */
async restoreKey(request: RestoreKeyRequest) : Promise<Result<RestoreKeyResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("restore_key", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update a key's label in the global registry
 * 
 * This command updates the label for keys in the global registry.
 * **CRITICAL SAFETY:** Only allows updates for keys that are NOT in Active state.
 * 
 * Active keys have their labels embedded in vault manifests. Renaming them would
 * cause manifest desynchronization issues.
 * 
 * **Allowed lifecycle states:**
 * - PreActivation (never attached or never used)
 * - Suspended (detached from all vaults)
 * - Deactivated (in grace period)
 * 
 * **Blocked lifecycle states:**
 * - Active (embedded in vault manifests - cannot rename safely)
 * 
 * **Note:** This only updates the registry. For Active keys, user must delete and
 * create a new key with the desired label.
 */
async updateGlobalKeyLabel(request: UpdateGlobalKeyLabelRequest) : Promise<Result<UpdateGlobalKeyLabelResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_global_key_label", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Select files or folder for encryption
 */
async selectFiles(selectionType: SelectionType) : Promise<Result<FileSelection, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("select_files", { selectionType }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Select a directory for output
 */
async selectDirectory(title: string | null) : Promise<Result<string, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("select_directory", { title }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get file/folder information
 */
async getFileInfo(paths: string[]) : Promise<Result<FileInfo[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_file_info", { paths }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create manifest for file set
 */
async createManifest(filePaths: string[]) : Promise<Result<Manifest, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_manifest", { filePaths }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new vault
 */
async createVault(input: CreateVaultRequest) : Promise<Result<CreateVaultResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_vault", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all vaults
 */
async listVaults() : Promise<Result<ListVaultsResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_vaults") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the current active vault (deprecated - UI should track this)
 */
async getCurrentVault() : Promise<Result<GetCurrentVaultResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_current_vault") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Set the current active vault (deprecated - UI should track this)
 */
async setCurrentVault(input: SetCurrentVaultRequest) : Promise<Result<SetCurrentVaultResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_current_vault", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a vault
 */
async deleteVault(input: DeleteVaultRequest) : Promise<Result<DeleteVaultResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_vault", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get statistics for a specific vault
 * 
 * This command aggregates vault statistics from the manifest and key registry.
 * It provides real-time data about vault usage, key status, and encryption history.
 */
async getVaultStatistics(request: GetVaultStatisticsRequest) : Promise<Result<GetVaultStatisticsResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_vault_statistics", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get statistics for all vaults
 * 
 * This command retrieves aggregated statistics across all vaults in the system.
 * It provides a comprehensive overview of vault usage and key management.
 */
async getAllVaultStatistics(request: GetAllVaultStatisticsRequest) : Promise<Result<GetAllVaultStatisticsResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_all_vault_statistics", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addPassphraseKeyToVault(input: AddPassphraseKeyRequest) : Promise<Result<AddPassphraseKeyResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_passphrase_key_to_vault", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async validateVaultPassphraseKey(vaultId: string) : Promise<Result<boolean, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("validate_vault_passphrase_key", { vaultId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Initialize a new YubiKey and add it to a vault
 * Delegates YubiKey operations to YubiKeyManager, handles vault integration
 */
async initYubikeyForVault(input: YubiKeyInitForVaultParams) : Promise<Result<YubiKeyVaultResult, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("init_yubikey_for_vault", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Register an existing YubiKey with a vault
 * Delegates YubiKey operations to YubiKeyManager, handles vault integration
 */
async registerYubikeyForVault(input: RegisterYubiKeyForVaultParams) : Promise<Result<YubiKeyVaultResult, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("register_yubikey_for_vault", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Attach an orphaned key to a vault
 * 
 * This command allows attaching any orphaned key (passphrase or YubiKey) to a vault.
 * It validates the key state, checks vault limits, and updates both registry and manifest.
 */
async attachKeyToVault(request: AttachKeyToVaultRequest) : Promise<Result<AttachKeyToVaultResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("attach_key_to_vault", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Import an external .enc key file into the registry
 * 
 * This command allows importing backup or external key files into the vault system.
 * It supports both passphrase-protected keys and YubiKey metadata files.
 * 
 * Features:
 * - Validates age encryption format
 * - Checks for duplicate keys by comparing public keys
 * - Sanitizes labels to prevent injection attacks
 * - Supports dry-run validation mode
 * - Can immediately attach imported keys to vaults
 * - Creates audit trail for security compliance
 */
async importKeyFile(request: ImportKeyFileRequest) : Promise<Result<ImportKeyFileResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("import_key_file", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all YubiKeys with intelligent state detection
 * Uses YubiKeyManager for centralized device and registry operations
 */
async listYubikeys() : Promise<Result<YubiKeyStateInfo[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_yubikeys") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Initialize a brand new YubiKey device
 * Uses YubiKeyManager for complete hardware and software initialization
 */
async initYubikey(serial: string, newPin: string, recoveryPin: string, label: string) : Promise<Result<StreamlinedYubiKeyInitResult, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("init_yubikey", { serial, newPin, recoveryPin, label }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Register an existing YubiKey device to global registry (vault-agnostic)
 * 
 * This command adds an already-initialized YubiKey (with existing age identity)
 * to the global key registry WITHOUT attaching it to any vault.
 * 
 * **Use Case:** YubiKey in "orphaned"/"suspended" state:
 * - Has age identity (was used before)
 * - NOT in current machine's registry
 * - User wants to add to registry for future vault attachment
 * 
 * **State Transitions:**
 * - Device State: Orphaned → Registered
 * - Lifecycle Status: Suspended → Active (NIST-aligned)
 * 
 * **Differs from init_yubikey:**
 * - init_yubikey: For NEW YubiKeys (generates new identity)
 * - register_yubikey: For ORPHANED YubiKeys (reads existing identity)
 */
async registerYubikey(serial: string, label: string, pin: string) : Promise<Result<StreamlinedYubiKeyInitResult, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("register_yubikey", { serial, label, pin }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Decrypt file using YubiKey with smart method selection
 * Currently uses existing implementation - will be migrated to YubiKeyManager in next iteration
 */
async yubikeyDecryptFile(encryptedFile: string, unlockMethod: UnlockMethod | null, credentials: UnlockCredentials, outputPath: string) : Promise<Result<VaultDecryptionResult, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("yubikey_decrypt_file", { encryptedFile, unlockMethod, credentials, outputPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type AddPassphraseKeyRequest = { vault_id: string; label: string; passphrase: string }
export type AddPassphraseKeyResponse = { key_reference: VaultKey; public_key: string }
/**
 * Request to analyze an encrypted vault file
 */
export type AnalyzeEncryptedVaultRequest = { 
/**
 * Absolute path to the encrypted .age file
 */
encrypted_file_path: string }
/**
 * Response containing vault analysis results
 */
export type AnalyzeEncryptedVaultResponse = { 
/**
 * Desanitized vault name for display (e.g., "Sam Family Vault")
 */
vault_name: string; 
/**
 * Sanitized vault name from filename (e.g., "Sam-Family-Vault")
 */
vault_name_sanitized: string; 
/**
 * Whether a vault manifest exists on this machine
 */
manifest_exists: boolean; 
/**
 * Vault ID if manifest was found, null otherwise
 */
vault_id: string | null; 
/**
 * Associated keys from manifest (empty if recovery mode)
 */
associated_keys: VaultKey[]; 
/**
 * Creation date extracted from filename (e.g., "2025-01-13")
 */
creation_date: string | null; 
/**
 * True if manifest is missing (disaster recovery scenario)
 */
is_recovery_mode: boolean }
/**
 * Request to attach a key to a vault
 */
export type AttachKeyToVaultRequest = { 
/**
 * The key ID to attach
 */
key_id: string; 
/**
 * The vault ID to attach to
 */
vault_id: string }
/**
 * Response from key attachment
 */
export type AttachKeyToVaultResponse = { success: boolean; message: string; key_id: string; vault_id: string }
/**
 * Unified error type for all commands with comprehensive error information
 * 
 * This struct provides detailed error information including:
 * - Error code for programmatic handling
 * - User-friendly message for display
 * - Optional technical details for debugging
 * - Recovery guidance for user actions
 * - Trace context for debugging
 * 
 * # TypeScript Equivalent
 * ```typescript
 * interface CommandError {
 * code: ErrorCode;
 * message: string;
 * details?: string;
 * recovery_guidance?: string;
 * user_actionable: boolean;
 * trace_id?: string;
 * span_id?: string;
 * }
 * ```
 */
export type CommandError = { 
/**
 * Error code for client-side handling
 */
code: ErrorCode; 
/**
 * User-friendly error message
 */
message: string; 
/**
 * Optional technical details for debugging
 */
details: string | null; 
/**
 * Optional guidance for user recovery
 */
recovery_guidance: string | null; 
/**
 * Whether the user can take action to resolve this error
 */
user_actionable: boolean; 
/**
 * Optional trace ID for debugging
 */
trace_id: string | null; 
/**
 * Optional span ID for debugging
 */
span_id: string | null }
/**
 * Input for creating a new vault
 */
export type CreateVaultRequest = { name: string; description: string | null }
/**
 * Response from vault creation
 */
export type CreateVaultResponse = { vault: VaultSummary }
/**
 * Request to deactivate a key
 */
export type DeactivateKeyRequest = { 
/**
 * The key ID to deactivate
 */
key_id: string; 
/**
 * Reason for deactivation (optional, for audit trail)
 */
reason: string | null; 
/**
 * If true, immediately destroy the key (skip 30-day grace period)
 * If false or None, use normal deactivation with 30-day grace period
 */
delete_immediately?: boolean | null }
/**
 * Response from key deactivation
 */
export type DeactivateKeyResponse = { success: boolean; key_id: string; new_status: KeyLifecycleStatus; 
/**
 * ISO 8601 timestamp when key was deactivated
 */
deactivated_at: string; 
/**
 * ISO 8601 timestamp when key will be permanently deleted (deactivated_at + 30 days)
 * None if delete_immediately was true
 */
deletion_scheduled_at: string | null }
/**
 * Input for decryption command
 */
export type DecryptDataInput = { encrypted_file: string; key_id: string; passphrase: string; output_dir: string }
/**
 * Result of decryption operation
 */
export type DecryptionResult = { extracted_files: string[]; output_dir: string; manifest_verified: boolean; external_manifest_restored?: boolean | null }
/**
 * Request to delete a key permanently
 */
export type DeleteKeyRequest = { 
/**
 * The key ID to delete
 */
key_id: string; 
/**
 * Reason for deletion (optional, for audit trail)
 */
reason: string | null }
/**
 * Response from key deletion
 */
export type DeleteKeyResponse = { success: boolean; key_id: string; new_status: KeyLifecycleStatus; 
/**
 * ISO 8601 timestamp when key was deleted
 */
deleted_at: string }
/**
 * Input for deleting a vault
 */
export type DeleteVaultRequest = { vault_id: string; force: boolean }
/**
 * Response from vault deletion
 */
export type DeleteVaultResponse = { success: boolean; message: string }
/**
 * Input for encryption command
 */
export type EncryptDataInput = { key_id: string; file_paths: string[]; output_name: string | null; output_path: string | null }
export type EncryptFilesMultiInput = { vault_id: string; in_file_paths: string[]; out_encrypted_file_name: string | null; out_encrypted_file_path: string | null }
/**
 * Response from multi-key encryption command
 */
export type EncryptFilesMultiResponse = { encrypted_file_path: string; manifest_file_path: string; file_exists_warning: boolean; keys_used: string[] }
/**
 * Encryption operation status
 */
export type EncryptionStatus = "Pending" | "InProgress" | "Completed" | "Failed" | "Cancelled"
/**
 * Response from encryption status command
 */
export type EncryptionStatusResponse = { operation_id: string; status: EncryptionStatus; progress_percentage: number; current_file: string | null; total_files: number; processed_files: number; total_size: number; processed_size: number; estimated_time_remaining: number | null; error_message: string | null }
/**
 * Error codes for client-side handling and internationalization
 * 
 * These codes enable the frontend to:
 * - Display appropriate error messages
 * - Implement error-specific recovery flows
 * - Provide localized error messages
 * - Handle errors programmatically
 * 
 * # TypeScript Equivalent
 * ```typescript
 * enum ErrorCode {
 * // Validation errors
 * INVALID_INPUT = 'INVALID_INPUT',
 * MISSING_PARAMETER = 'MISSING_PARAMETER',
 * // ... etc
 * }
 * ```
 */
export type ErrorCode = "INVALID_INPUT" | "MISSING_PARAMETER" | "INVALID_PATH" | "INVALID_KEY_LABEL" | "WEAK_PASSPHRASE" | "INVALID_FILE_FORMAT" | "FILE_TOO_LARGE" | "TOO_MANY_FILES" | "PERMISSION_DENIED" | "PATH_NOT_ALLOWED" | "INSUFFICIENT_PERMISSIONS" | "READ_ONLY_FILE_SYSTEM" | "KEY_NOT_FOUND" | "FILE_NOT_FOUND" | "DIRECTORY_NOT_FOUND" | "OPERATION_NOT_FOUND" | "ENCRYPTION_FAILED" | "DECRYPTION_FAILED" | "STORAGE_FAILED" | "ARCHIVE_CORRUPTED" | "MANIFEST_INVALID" | "INTEGRITY_CHECK_FAILED" | "CONCURRENT_OPERATION" | "DISK_SPACE_INSUFFICIENT" | "MEMORY_INSUFFICIENT" | "FILE_SYSTEM_ERROR" | "NETWORK_ERROR" | "INVALID_KEY" | "WRONG_PASSPHRASE" | "TAMPERED_DATA" | "UNAUTHORIZED_ACCESS" | "YUBI_KEY_ERROR" | "YUBI_KEY_NOT_FOUND" | "YUBI_KEY_PIN_REQUIRED" | "YUBI_KEY_PIN_BLOCKED" | "YUBI_KEY_TOUCH_REQUIRED" | "YUBI_KEY_TOUCH_TIMEOUT" | "WRONG_YUBI_KEY" | "YUBI_KEY_SLOT_IN_USE" | "YUBI_KEY_INITIALIZATION_FAILED" | "YUBI_KEY_COMMUNICATION_ERROR" | "VAULT_NOT_FOUND" | "VAULT_ALREADY_EXISTS" | "VAULT_KEY_LIMIT_EXCEEDED" | "KEY_ALREADY_EXISTS" | "INVALID_KEY_STATE" | "PLUGIN_NOT_FOUND" | "PLUGIN_VERSION_MISMATCH" | "PLUGIN_EXECUTION_FAILED" | "PLUGIN_DEPLOYMENT_FAILED" | "NO_UNLOCK_METHOD_AVAILABLE" | "RECIPIENT_MISMATCH" | "MULTI_RECIPIENT_SETUP_FAILED" | "INTERNAL_ERROR" | "UNEXPECTED_ERROR" | "CONFIGURATION_ERROR" | "UNKNOWN_ERROR"
/**
 * Request to export a key to a destination path
 */
export type ExportKeyRequest = { 
/**
 * The key ID to export
 */
key_id: string; 
/**
 * The full destination path where the key file should be copied
 */
destination_path: string }
/**
 * Response from key export
 */
export type ExportKeyResponse = { success: boolean; 
/**
 * The path where the file was exported
 */
exported_file: string; 
/**
 * Size of the exported file in bytes
 */
file_size: number }
/**
 * File information
 */
export type FileInfo = { path: string; name: string; size: number; is_file: boolean; is_directory: boolean; file_count: number | null }
/**
 * File selection result
 */
export type FileSelection = { paths: string[]; total_size: number; file_count: number; selection_type: string }
export type GenerateKeyInput = { label: string; passphrase: string }
export type GenerateKeyResponse = { public_key: string; key_id: string; saved_path: string }
/**
 * Request for getting all vault statistics (can be empty)
 */
export type GetAllVaultStatisticsRequest = { 
/**
 * Optional filter by vault status
 */
status_filter: string | null }
/**
 * Response containing global vault statistics
 */
export type GetAllVaultStatisticsResponse = { success: boolean; statistics: GlobalVaultStatistics | null; error: string | null }
/**
 * Response containing current vault
 */
export type GetCurrentVaultResponse = { vault: VaultSummary | null }
/**
 * Input for encryption status command
 */
export type GetEncryptionStatusInput = { operation_id: string }
/**
 * Request for key menu data
 */
export type GetKeyMenuDataRequest = { vault_id: string }
/**
 * Response with structured key menu data
 */
export type GetKeyMenuDataResponse = { vault_id: string; keys: VaultKey[] }
/**
 * Input for progress status command
 */
export type GetProgressInput = { operation_id: string }
/**
 * Response from progress status command
 */
export type GetProgressResponse = { operation_id: string; progress: number; message: string; details: ProgressDetails | null; timestamp: string; estimated_time_remaining: number | null; is_complete: boolean }
/**
 * Input for getting vault keys
 */
export type GetVaultKeysRequest = { vault_id: string; 
/**
 * Include all keys regardless of availability (for decrypt operations)
 */
include_all: boolean | null }
/**
 * Response containing vault keys
 */
export type GetVaultKeysResponse = { vault_id: string; keys: VaultKey[] }
/**
 * Request for getting single vault statistics
 */
export type GetVaultStatisticsRequest = { 
/**
 * The vault ID (deterministic unique identifier)
 */
vault_id: string }
/**
 * Response containing vault statistics
 */
export type GetVaultStatisticsResponse = { success: boolean; statistics: VaultStatistics | null; error: string | null }
/**
 * Complete key information for global contexts
 * 
 * Used when managing keys across all vaults (ManageKeys page, global key registry).
 * Contains ALL fields including vault_associations, recipient, availability, and metadata.
 * 
 * For vault-specific contexts (Encrypt/Decrypt pages), use `VaultKey` instead which
 * contains only the minimal fields needed for vault operations.
 */
export type GlobalKey = { 
/**
 * Unique identifier for this key
 */
id: string; 
/**
 * User-friendly label
 */
label: string; 
/**
 * Type-specific information
 */
key_type: KeyType; 
/**
 * Age recipient string for encryption
 */
recipient: string; 
/**
 * Whether key is currently available (green vs blue in UI)
 */
is_available: boolean; 
/**
 * Array of vault IDs this key is attached to (supports multi-vault per NIST)
 * Empty array means key is not attached to any vault (orphaned/suspended)
 */
vault_associations: string[]; 
/**
 * Current lifecycle status
 */
lifecycle_status: KeyLifecycleStatus; 
/**
 * When this key was created
 */
created_at: string; 
/**
 * Last time this key was used
 */
last_used: string | null; 
/**
 * Additional metadata for YubiKey keys
 */
yubikey_info: YubiKeyInfo | null; 
/**
 * Timestamp when key was deactivated (null if not deactivated)
 * Used to calculate days remaining before permanent deletion
 */
deactivated_at?: string | null }
/**
 * Summary statistics across all vaults
 */
export type GlobalVaultStatistics = { total_vaults: number; active_vaults: number; new_vaults: number; orphaned_vaults: number; total_encryptions: number; total_files: number; total_size_bytes: number; vault_statistics: VaultStatistics[] }
/**
 * Request to import a key file
 */
export type ImportKeyFileRequest = { 
/**
 * Path to the .enc file to import
 */
file_path: string; 
/**
 * Passphrase for encrypted .enc files (optional)
 */
passphrase: string | null; 
/**
 * Override the label extracted from file name (optional)
 */
override_label: string | null; 
/**
 * Immediately attach to a vault after import (optional)
 */
attach_to_vault: string | null; 
/**
 * Only validate without actually importing (dry-run mode)
 */
validate_only: boolean }
/**
 * Response from key import
 */
export type ImportKeyFileResponse = { 
/**
 * The imported or validated key reference
 */
key_reference: VaultKey; 
/**
 * Validation status information
 */
validation_status: ValidationStatus; 
/**
 * Any warnings encountered during import
 */
import_warnings: string[] }
/**
 * Detailed information about a key
 */
export type KeyDetail = { key_id: string; label: string; key_type: string; lifecycle_status: KeyLifecycleStatus; created_at: string; last_used: string | null; is_available: boolean }
/**
 * NIST-aligned lifecycle states for encryption keys
 */
export type KeyLifecycleStatus = 
/**
 * Key generated but never used
 */
"pre_activation" | 
/**
 * Currently attached to vault(s) and available for operations
 */
"active" | 
/**
 * Temporarily disabled but can be reactivated
 */
"suspended" | 
/**
 * Permanently disabled, cannot be reactivated
 */
"deactivated" | 
/**
 * Cryptographically destroyed, only metadata remains
 */
"destroyed" | 
/**
 * Security breach detected, immediate deactivation required
 */
"compromised"
/**
 * Filter options for key listing operations
 */
export type KeyListFilter = 
/**
 * All registered keys across all vaults
 */
{ type: "All" } | 
/**
 * Keys registered to a specific vault
 */
{ type: "ForVault"; value: string } | 
/**
 * Keys NOT in a specific vault but available to add
 */
{ type: "AvailableForVault"; value: string } | 
/**
 * Only currently connected/available keys (for decryption UI)
 */
{ type: "ConnectedOnly" }
/**
 * Simplified key metadata for frontend
 */
export type KeyMetadata = { label: string; created_at: string; public_key: string }
/**
 * Key statistics for a vault
 */
export type KeyStatistics = { total_keys: number; active_keys: number; orphaned_keys: number; passphrase_keys: number; yubikey_keys: number; key_details: KeyDetail[] }
/**
 * Type of key with type-specific data
 */
export type KeyType = 
/**
 * Passphrase-based key
 */
{ type: "Passphrase"; data: { 
/**
 * Reference to the stored key file
 */
key_id: string } } | 
/**
 * YubiKey hardware token
 */
{ type: "YubiKey"; data: { 
/**
 * Serial number of the YubiKey
 */
serial: string; 
/**
 * Firmware version for compatibility tracking
 */
firmware_version?: string | null } }
/**
 * Response containing list of vaults
 */
export type ListVaultsResponse = { vaults: VaultSummary[] }
/**
 * Manifest for encrypted archives
 */
export type Manifest = { version: string; created_at: string; files: FileInfo[]; total_size: number; file_count: number }
export type PassphraseStrength = "weak" | "fair" | "good" | "strong"
export type PassphraseValidationResult = { is_valid: boolean; strength: PassphraseStrength; feedback: string[]; score: number }
/**
 * PIN status for YubiKey
 */
export type PinStatus = "default" | "custom" | "blocked" | "unknown"
/**
 * Operation-specific progress details for different command types
 * 
 * This enum provides detailed progress information specific to different operation types.
 * The frontend can use this to display operation-specific progress indicators.
 * 
 * # TypeScript Equivalent
 * ```typescript
 * type ProgressDetails =
 * | { type: 'FileOperation'; current_file: string; total_files: number; current_file_progress: number; current_file_size: number; total_size: number }
 * | { type: 'Encryption'; bytes_processed: number; total_bytes: number; encryption_rate?: number }
 * | { type: 'Decryption'; bytes_processed: number; total_bytes: number; decryption_rate?: number }
 * | { type: 'ArchiveOperation'; files_processed: number; total_files: number; bytes_processed: number; total_bytes: number; compression_ratio?: number }
 * | { type: 'ManifestOperation'; files_verified: number; total_files: number; current_file: string };
 * ```
 */
export type ProgressDetails = 
/**
 * File operation progress (copying, moving, etc.)
 */
{ type: "FileOperation"; current_file: string; total_files: number; current_file_progress: number; current_file_size: number; total_size: number } | 
/**
 * Encryption operation progress
 */
{ type: "Encryption"; bytes_processed: number; total_bytes: number; encryption_rate: number | null } | 
/**
 * Decryption operation progress
 */
{ type: "Decryption"; bytes_processed: number; total_bytes: number; decryption_rate: number | null } | 
/**
 * Archive operation progress (compression, extraction)
 */
{ type: "ArchiveOperation"; files_processed: number; total_files: number; bytes_processed: number; total_bytes: number; compression_ratio: number | null } | 
/**
 * Manifest operation progress (verification, generation)
 */
{ type: "ManifestOperation"; files_verified: number; total_files: number; current_file: string } | 
/**
 * YubiKey operation progress
 */
{ type: "YubiKeyOperation"; operation: YubiKeyOperationType; phase: YubiKeyPhase; requires_interaction: boolean; context: string | null }
/**
 * YubiKey registration parameters for vault
 */
export type RegisterYubiKeyForVaultParams = { serial: string; pin: string; label: string; vault_id: string }
/**
 * Input for removing key from vault
 */
export type RemoveKeyFromVaultRequest = { vault_id: string; key_id: string }
/**
 * Response from removing key
 */
export type RemoveKeyFromVaultResponse = { success: boolean }
/**
 * Request to restore a deactivated key
 */
export type RestoreKeyRequest = { 
/**
 * The key ID to restore
 */
key_id: string }
/**
 * Response from key restoration
 */
export type RestoreKeyResponse = { success: boolean; key_id: string; 
/**
 * The restored status (Active or Suspended, based on previous state)
 */
new_status: KeyLifecycleStatus; 
/**
 * ISO 8601 timestamp when key was restored
 */
restored_at: string }
/**
 * File selection type
 */
export type SelectionType = "Files" | "Folder"
/**
 * Input for setting current vault
 */
export type SetCurrentVaultRequest = { vault_id: string }
/**
 * Response from setting current vault
 */
export type SetCurrentVaultResponse = { success: boolean; vault: VaultSummary }
export type StreamlinedYubiKeyInitResult = { serial: string; slot: number; recipient: string; identity_tag: string; label: string }
/**
 * Credentials for unlocking vaults
 */
export type UnlockCredentials = { Passphrase: { key_label: string; passphrase: string } } | { YubiKey: { serial: string; pin: string | null } }
/**
 * Unlock methods available for decryption
 */
export type UnlockMethod = "Passphrase" | "YubiKey"
/**
 * Request to update a key's label in the global registry
 */
export type UpdateGlobalKeyLabelRequest = { 
/**
 * The key ID to update
 */
key_id: string; 
/**
 * The new label for the key
 */
new_label: string }
/**
 * Response from global key label update
 */
export type UpdateGlobalKeyLabelResponse = { success: boolean; 
/**
 * The key ID that was updated
 */
key_id: string; 
/**
 * The new label
 */
updated_label: string }
/**
 * Input for updating key label
 */
export type UpdateKeyLabelRequest = { vault_id: string; key_id: string; new_label: string }
/**
 * Response from updating key label
 */
export type UpdateKeyLabelResponse = { success: boolean }
export type ValidatePassphraseInput = { passphrase: string }
export type ValidatePassphraseResponse = { is_valid: boolean; message: string }
/**
 * Validation status for imported keys
 */
export type ValidationStatus = { 
/**
 * Whether the key file is valid
 */
is_valid: boolean; 
/**
 * Whether this key already exists in the registry
 */
is_duplicate: boolean; 
/**
 * Original metadata from the key file
 */
original_metadata: KeyMetadata | null }
export type VaultDecryptionResult = { method_used: UnlockMethod; recipient_used: string; files_extracted: string[]; output_path: string; decryption_time: string }
/**
 * Minimal key information for vault-specific contexts
 * 
 * Used when displaying keys within a single vault context (Encrypt/Decrypt pages).
 * Contains only the essential fields needed for vault operations.
 * 
 * For global key management (ManageKeys page), use `GlobalKey` instead which includes
 * vault_associations, recipient, is_available, and yubikey_info fields.
 */
export type VaultKey = 
/**
 * Type of key
 */
(
/**
 * Passphrase-based key
 */
{ type: "Passphrase"; data: { 
/**
 * Reference to the stored key file
 */
key_id: string } } | 
/**
 * YubiKey hardware token
 */
{ type: "YubiKey"; data: { 
/**
 * Serial number of the YubiKey
 */
serial: string; 
/**
 * Firmware version for compatibility tracking
 */
firmware_version?: string | null } }) & { 
/**
 * Unique identifier for this key reference
 */
id: string; 
/**
 * User-friendly label
 */
label: string; 
/**
 * Current lifecycle status of the key
 */
lifecycle_status: KeyLifecycleStatus; 
/**
 * When this key was added to the vault
 */
created_at: string; 
/**
 * Last time this key was used
 */
last_used: string | null }
/**
 * Statistics for a single vault
 */
export type VaultStatistics = { vault_id: string; vault_name: string; description: string | null; status: VaultStatus; encryption_count: number; created_at: string; last_encrypted_at: string | null; last_encrypted_by: string | null; file_count: number; total_size_bytes: number; key_statistics: KeyStatistics; archive_exists: boolean; manifest_exists: boolean }
/**
 * Vault status based on encryption history
 */
export type VaultStatus = 
/**
 * Never encrypted (encryption_count = 0)
 */
"new" | 
/**
 * Has been encrypted at least once
 */
"active" | 
/**
 * Archive exists but manifest is missing or corrupted
 */
"orphaned" | 
/**
 * Manifest exists but archive is missing
 */
"incomplete"
/**
 * Summary information about a vault (for listing)
 */
export type VaultSummary = { id: string; name: string; description: string | null; created_at: string; key_count: number }
export type VerifyKeyPassphraseInput = { key_id: string; passphrase: string }
export type VerifyKeyPassphraseResponse = { is_valid: boolean; message: string }
/**
 * Input for manifest verification command
 */
export type VerifyManifestInput = { manifest_path: string; extracted_files_dir: string }
/**
 * Response from manifest verification command
 */
export type VerifyManifestResponse = { is_valid: boolean; message: string; file_count: number; total_size: number }
/**
 * YubiKey-specific information for unified API
 */
export type YubiKeyInfo = { slot: number | null; identity_tag: string | null; pin_status: PinStatus; yubikey_state: YubiKeyState }
/**
 * YubiKey initialization parameters for vault
 */
export type YubiKeyInitForVaultParams = { serial: string; pin: string; label: string; vault_id: string }
/**
 * Types of YubiKey operations
 */
export type YubiKeyOperationType = "Detection" | "Initialization" | "Authentication" | "KeyGeneration" | "Encryption" | "Decryption" | "PluginDeployment"
/**
 * Phases of YubiKey operations
 */
export type YubiKeyPhase = "Starting" | { InProgress: { percentage: number | null } } | "WaitingForPin" | "WaitingForTouch" | "Completing" | "Completed" | { Failed: { error: string } }
/**
 * YubiKey state - Device-level hardware initialization status
 * 
 * This enum tracks YubiKey DEVICE state (hardware initialization).
 * For registry-level lifecycle state, see `KeyLifecycleStatus` (NIST-aligned).
 * 
 * **Architecture Note:** This is intentionally separate from KeyLifecycleStatus:
 * - YubiKeyState = Device-level (hardware initialization status)
 * - KeyLifecycleStatus = Registry-level (NIST SP 800-57 lifecycle state)
 * 
 * Both systems coexist with clear mapping (see NIST Mapping below).
 * 
 * This replaces the duplicate YubiKeyState enums found in:
 * - commands/yubikey_commands/streamlined.rs:24
 * - crypto/yubikey/age_plugin.rs:33
 */
export type YubiKeyState = 
/**
 * Brand new YubiKey with default PIN (123456)
 * - PIN: Default (123456)
 * - Age identity: None
 * - Manifest entry: None
 * - Action needed: Initialize with custom PIN and generate age identity
 * - **NIST Mapping:** KeyLifecycleStatus::PreActivation
 */
"new" | 
/**
 * YubiKey with custom PIN but no age identity registered
 * - PIN: Custom (changed from default)
 * - Age identity: None
 * - Manifest entry: None
 * - Action needed: Generate age identity for Barqly
 * - **NIST Mapping:** KeyLifecycleStatus::PreActivation
 */
"reused" | 
/**
 * YubiKey with age identity already registered and ready to use
 * - PIN: Custom
 * - Age identity: Present and valid
 * - Manifest entry: Present and valid
 * - Action needed: None (ready for operations)
 * - **NIST Mapping:** KeyLifecycleStatus::Active
 */
"registered" | 
/**
 * YubiKey has age identity but no manifest entry (needs recovery)
 * - PIN: Custom
 * - Age identity: Present
 * - Manifest entry: Missing or invalid
 * - Action needed: Recover manifest entry or re-register
 * - **NIST Mapping:** KeyLifecycleStatus::Suspended (was active, now detached)
 * 
 * **Note:** This device state name is kept for backward compatibility.
 * When creating registry entries, use KeyLifecycleStatus::Suspended instead.
 */
"orphaned"
export type YubiKeyStateInfo = { serial: string; 
/**
 * Device-level state (hardware initialization status)
 */
state: YubiKeyState; 
/**
 * Registry-level lifecycle status (NIST-aligned) for consistent UI badges
 */
lifecycle_status: KeyLifecycleStatus; slot: number | null; recipient: string | null; identity_tag: string | null; label: string | null; pin_status: PinStatus; firmware_version: string | null; created_at: string; last_used: string | null }
/**
 * Result from YubiKey operations
 */
export type YubiKeyVaultResult = { success: boolean; key_reference: VaultKey; recovery_code_hash: string }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
