
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
/**
 * Generate a new encryption keypair
 */
async generateKey(input: GenerateKeyInput) : Promise<Result<GenerateKeyResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("generate_key", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Generate a new encryption keypair with multi-recipient support
 */
async generateKeyMulti(input: GenerateKeyMultiInput) : Promise<Result<GenerateKeyMultiResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("generate_key_multi", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Validate passphrase strength
 */
async validatePassphrase(input: ValidatePassphraseInput) : Promise<Result<ValidatePassphraseResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("validate_passphrase", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Verify that a passphrase can decrypt a specific key
 * 
 * This command efficiently validates a key-passphrase combination
 * without performing full file decryption. It only attempts to decrypt
 * the private key, making it suitable for validation workflows.
 * 
 * # Security
 * - Constant-time operations where possible to prevent timing attacks
 * - No unnecessary file I/O or temporary file creation
 * - Proper error handling without information leakage
 * 
 * # Performance
 * - Fast operation independent of encrypted file size
 * - Only loads and decrypts the private key
 * - Minimal memory footprint
 */
async verifyKeyPassphrase(input: VerifyKeyPassphraseInput) : Promise<Result<VerifyKeyPassphraseResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("verify_key_passphrase", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Validate passphrase strength with detailed feedback
 */
async validatePassphraseStrength(passphrase: string) : Promise<Result<PassphraseValidationResult, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("validate_passphrase_strength", { passphrase }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Encrypt files with progress streaming
 */
async encryptFiles(input: EncryptDataInput) : Promise<Result<string, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("encrypt_files", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get encryption operation status
 */
async getEncryptionStatus(input: GetEncryptionStatusInput) : Promise<Result<EncryptionStatusResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_encryption_status", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Decrypt files with progress streaming
 */
async decryptData(input: DecryptDataInput) : Promise<Result<DecryptionResult, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("decrypt_data", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Verify a manifest file against extracted files
 */
async verifyManifest(input: VerifyManifestInput) : Promise<Result<VerifyManifestResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("verify_manifest", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get progress for a long-running operation
 */
async getProgress(input: GetProgressInput) : Promise<Result<GetProgressResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_progress", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all available keys
 */
async listKeysCommand() : Promise<Result<KeyMetadata[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_keys_command") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a key by ID
 */
async deleteKeyCommand(keyId: string) : Promise<Result<null, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_key_command", { keyId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get application configuration
 */
async getConfig() : Promise<Result<AppConfig, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_config") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update application configuration
 */
async updateConfig(config: AppConfigUpdate) : Promise<Result<null, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_config", { config }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get cache performance metrics
 */
async getCacheMetrics() : Promise<Result<CacheMetrics, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_cache_metrics") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Select files or folder for encryption
 */
async selectFiles(selectionType: SelectionType) : Promise<Result<FileSelection, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("select_files", { selectionType }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Select a directory for output
 */
async selectDirectory(title: string | null) : Promise<Result<string, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("select_directory", { title }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get file/folder information
 */
async getFileInfo(paths: string[]) : Promise<Result<FileInfo[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_file_info", { paths }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create manifest for file set
 */
async createManifest(filePaths: string[]) : Promise<Result<Manifest, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_manifest", { filePaths }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new vault
 */
async createVault(input: CreateVaultRequest) : Promise<Result<CreateVaultResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_vault", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all vaults
 */
async listVaults() : Promise<Result<ListVaultsResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_vaults") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the current active vault (deprecated - UI should track this)
 */
async getCurrentVault() : Promise<Result<GetCurrentVaultResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_current_vault") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Set the current active vault (deprecated - UI should track this)
 */
async setCurrentVault(input: SetCurrentVaultRequest) : Promise<Result<SetCurrentVaultResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_current_vault", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a vault
 */
async deleteVault(input: DeleteVaultRequest) : Promise<Result<DeleteVaultResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_vault", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get all keys for a vault
 */
async getVaultKeys(input: GetVaultKeysRequest) : Promise<Result<GetVaultKeysResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_vault_keys", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Add a key to a vault
 */
async addKeyToVault(input: AddKeyToVaultRequest) : Promise<Result<AddKeyToVaultResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_key_to_vault", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Remove a key from a vault
 */
async removeKeyFromVault(input: RemoveKeyFromVaultRequest) : Promise<Result<RemoveKeyFromVaultResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_key_from_vault", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update a key's label
 */
async updateKeyLabel(input: UpdateKeyLabelRequest) : Promise<Result<UpdateKeyLabelResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_key_label", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check YubiKey availability
 */
async checkYubikeyAvailability(input: CheckYubiKeyAvailabilityRequest) : Promise<Result<CheckYubiKeyAvailabilityResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_yubikey_availability", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Add a passphrase key to a vault with actual key generation
 */
async addPassphraseKeyToVault(input: AddPassphraseKeyRequest) : Promise<Result<AddPassphraseKeyResponse, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_passphrase_key_to_vault", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if a passphrase key exists and is valid
 */
async validateVaultPassphraseKey(vaultId: string) : Promise<Result<boolean, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("validate_vault_passphrase_key", { vaultId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Initialize a new YubiKey and add it to a vault
 */
async initYubikeyForVault(input: YubiKeyInitForVaultParams) : Promise<Result<YubiKeyInitResult, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("init_yubikey_for_vault", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Register an existing YubiKey with a vault
 */
async registerYubikeyForVault(input: RegisterYubiKeyForVaultParams) : Promise<Result<RegisterYubiKeyResult, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("register_yubikey_for_vault", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List available YubiKeys with vault context
 */
async listAvailableYubikeys(vaultId: string) : Promise<Result<YubiKeyStateInfo[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_available_yubikeys", { vaultId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check which YubiKey slots are available in a vault
 */
async checkYubikeySlotAvailability(vaultId: string) : Promise<Result<boolean[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_yubikey_slot_availability", { vaultId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all available YubiKey recipients using age-plugin-yubikey
 * 
 * Returns information about YubiKey recipients available through age-plugin-yubikey,
 * converted to the legacy YubiKeyDevice format for compatibility.
 * 
 * If age-plugin-yubikey is not installed or no YubiKey devices are found,
 * this function returns an empty array rather than failing.
 * 
 * # Returns
 * Vector of YubiKeyDevice containing device information (empty if no devices found)
 */
async yubikeyListDevices() : Promise<Result<YubiKeyDevice[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("yubikey_list_devices") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if YubiKey devices are available using age-plugin-yubikey
 * 
 * Quick check to determine if YubiKey recipients are available through
 * age-plugin-yubikey without returning detailed device information.
 * 
 * # Returns
 * Boolean indicating if YubiKey devices are available
 */
async yubikeyDevicesAvailable() : Promise<Result<boolean, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("yubikey_devices_available") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get detailed information about a specific YubiKey device
 * 
 * # Arguments
 * * `serial` - The serial number of the YubiKey device
 * 
 * # Returns
 * YubiKeyDevice with detailed information about the specified device
 * 
 * # Errors
 * - `YubiKeyNotFound` if the specified device is not found
 * - `YubiKeyCommunicationError` if unable to communicate with the device
 */
async yubikeyGetDeviceInfo(serial: string) : Promise<Result<YubiKeyDevice, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("yubikey_get_device_info", { serial }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Test YubiKey connectivity using age-plugin-yubikey
 * 
 * # Arguments
 * * `serial` - The serial number of the YubiKey device to test
 * * `pin` - The PIN for the YubiKey device (used for validation only)
 * 
 * # Returns
 * Success indicator and any relevant status information
 * 
 * # Errors
 * - `YubiKeyNotFound` if the specified device is not found
 * - `PluginExecutionFailed` if age-plugin-yubikey fails
 * - `YubiKeyCommunicationError` if unable to communicate with the device
 */
async yubikeyTestConnection(serial: string, pin: string) : Promise<Result<YubiKeyConnectionTest, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("yubikey_test_connection", { serial, pin }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Initialize a YubiKey for use with Barqly Vault using age-plugin-yubikey
 * 
 * This command sets up a YubiKey for encryption using the mature age-plugin-yubikey
 * ecosystem for reliable hardware security operations.
 * 
 * # Arguments
 * * `serial` - The serial number of the YubiKey to initialize (optional, for logging)
 * * `pin` - The current PIN for the YubiKey (6-8 digits)
 * * `slot` - Optional specific slot to use (ignored, auto-selected by age-plugin-yubikey)
 * * `label` - Human-readable label for this YubiKey setup
 * 
 * # Returns
 * YubiKeyInitResult containing the public key and configuration
 * 
 * # Errors
 * - `YubiKeyNotFound` if no YubiKey device is connected
 * - `YubiKeyPinRequired` if PIN authentication fails
 * - `PluginExecutionFailed` if age-plugin-yubikey operation fails
 * - `YubiKeyInitializationFailed` if key generation fails
 */
async yubikeyInitialize(serial: string, pin: string, slot: number | null, label: string) : Promise<Result<YubiKeyInitResult, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("yubikey_initialize", { serial, pin, slot, label }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get YubiKey setup recommendations using age-plugin-yubikey
 * 
 * Provides general recommendations for YubiKey setup with age-plugin-yubikey,
 * including security policies and compatibility notes.
 * 
 * # Arguments
 * * `serial` - The serial number of the YubiKey to analyze (optional)
 * 
 * # Returns
 * YubiKeySetupRecommendations with suggested configuration
 */
async yubikeyGetSetupRecommendations(serial: string) : Promise<Result<YubiKeySetupRecommendations, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("yubikey_get_setup_recommendations", { serial }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Validate YubiKey PIN format
 * 
 * Checks if a PIN meets YubiKey requirements without attempting authentication.
 * 
 * # Arguments
 * * `pin` - The PIN to validate
 * 
 * # Returns
 * PinValidationResult with validation status and guidance
 */
async yubikeyValidatePin(pin: string) : Promise<Result<PinValidationResult, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("yubikey_validate_pin", { pin }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check YubiKey setup status using age-plugin-yubikey
 * 
 * Determines if YubiKey identities are available by listing recipients
 * from the age-plugin-yubikey system.
 * 
 * # Arguments
 * * `serial` - The serial number of the YubiKey to check (optional)
 * 
 * # Returns
 * YubiKeySetupStatus indicating current setup state
 */
async yubikeyCheckSetupStatus(serial: string) : Promise<Result<YubiKeySetupStatus, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("yubikey_check_setup_status", { serial }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Decrypt a vault with smart method selection
 * 
 * This command automatically determines the best unlock method based on
 * the vault's protection mode and currently available unlock methods.
 * 
 * # Arguments
 * * `encrypted_file` - Path to the encrypted vault file
 * * `unlock_method` - Optional preferred unlock method (auto-selected if None)
 * * `credentials` - Credentials for unlocking (passphrase or YubiKey info)
 * * `output_path` - Directory where decrypted files should be extracted
 * 
 * # Returns
 * DecryptionResult with information about the decryption process
 */
async yubikeyDecryptFile(encryptedFile: string, unlockMethod: UnlockMethod | null, credentials: UnlockCredentials, outputPath: string) : Promise<Result<VaultDecryptionResult, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("yubikey_decrypt_file", { encryptedFile, unlockMethod, credentials, outputPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get available unlock methods for a vault
 * 
 * Analyzes a vault and determines which unlock methods are currently
 * available based on the vault's recipients and system state.
 * 
 * # Arguments
 * * `encrypted_file` - Path to the encrypted vault file
 * 
 * # Returns
 * AvailableUnlockMethods with information about available methods
 */
async yubikeyGetAvailableUnlockMethods(filePath: string) : Promise<Result<AvailableMethod[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("yubikey_get_available_unlock_methods", { filePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Test unlock credentials without performing decryption
 * 
 * Validates that the provided credentials can successfully unlock the vault
 * without actually decrypting and extracting the contents.
 * 
 * # Arguments
 * * `encrypted_file` - Path to the encrypted vault file
 * * `credentials` - Credentials to test
 * 
 * # Returns
 * CredentialsTestResult with validation status
 */
async yubikeyTestUnlockCredentials(encryptedFile: string, credentials: UnlockCredentials) : Promise<Result<CredentialsTestResult, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("yubikey_test_unlock_credentials", { encryptedFile, credentials }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List YubiKeys with intelligent state detection
 */
async listYubikeys() : Promise<Result<YubiKeyStateInfo[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_yubikeys") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Initialize a brand new YubiKey
 */
async initYubikey(serial: string, newPin: string, label: string) : Promise<Result<StreamlinedYubiKeyInitResult, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("init_yubikey", { serial, newPin, label }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Register a reused YubiKey
 */
async registerYubikey(serial: string, label: string, pin: string) : Promise<Result<StreamlinedYubiKeyInitResult, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("register_yubikey", { serial, label, pin }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get identities for a specific YubiKey
 */
async getIdentities(serial: string) : Promise<Result<string[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_identities", { serial }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

/**
 * Input for adding a key to vault
 */
export type AddKeyToVaultRequest = { vault_id: string; key_type: string; passphrase: string | null; yubikey_serial: string | null; label: string }
/**
 * Response from adding key
 */
export type AddKeyToVaultResponse = { success: boolean; key_reference: KeyReference }
/**
 * Enhanced add key to vault request with passphrase support
 */
export type AddPassphraseKeyRequest = { vault_id: string; label: string; passphrase: string }
/**
 * Response after adding a passphrase key
 */
export type AddPassphraseKeyResponse = { key_reference: KeyReference; public_key: string }
/**
 * Application configuration
 */
export type AppConfig = { version: string; default_key_label: string | null; remember_last_folder: boolean; max_recent_files: number }
/**
 * Configuration update
 */
export type AppConfigUpdate = { default_key_label: string | null; remember_last_folder: boolean | null; max_recent_files: number | null }
/**
 * Available unlock method matching frontend structure
 */
export type AvailableMethod = { method_type: UnlockMethod; display_name: string; description: string; requires_hardware: boolean; estimated_time: string; confidence_level: ConfidenceLevel }
/**
 * Cache performance metrics
 */
export type CacheMetrics = { key_list_hits: number; key_list_misses: number; directory_hits: number; directory_misses: number; total_requests: number; cache_invalidations: number }
/**
 * Input for checking YubiKey availability
 */
export type CheckYubiKeyAvailabilityRequest = { serial: string }
/**
 * Response from YubiKey availability check
 */
export type CheckYubiKeyAvailabilityResponse = { is_inserted: boolean; is_configured: boolean; needs_recovery: boolean }
/**
 * Unified error type for all commands with comprehensive error information
 * 
 * This struct provides detailed error information including:
 * - Error code for programmatic handling
 * - User-friendly message for display
 * - Optional technical details for debugging
 * - Recovery guidance for user actions
 * - Trace context for debugging
 * 
 * # TypeScript Equivalent
 * ```typescript
 * interface CommandError {
 * code: ErrorCode;
 * message: string;
 * details?: string;
 * recovery_guidance?: string;
 * user_actionable: boolean;
 * trace_id?: string;
 * span_id?: string;
 * }
 * ```
 */
export type CommandError = { 
/**
 * Error code for client-side handling
 */
code: ErrorCode; 
/**
 * User-friendly error message
 */
message: string; 
/**
 * Optional technical details for debugging
 */
details: string | null; 
/**
 * Optional guidance for user recovery
 */
recovery_guidance: string | null; 
/**
 * Whether the user can take action to resolve this error
 */
user_actionable: boolean; 
/**
 * Optional trace ID for debugging
 */
trace_id: string | null; 
/**
 * Optional span ID for debugging
 */
span_id: string | null }
/**
 * Method confidence level matching frontend expectations
 */
export type ConfidenceLevel = "High" | "Medium" | "Low"
/**
 * Input for creating a new vault
 */
export type CreateVaultRequest = { name: string; description: string | null }
/**
 * Response from vault creation
 */
export type CreateVaultResponse = { vault: VaultSummary }
/**
 * Result of credentials testing
 */
export type CredentialsTestResult = { valid: boolean; method: UnlockMethod; message: string }
/**
 * Input for decryption command
 */
export type DecryptDataInput = { encrypted_file: string; key_id: string; passphrase: string; output_dir: string }
/**
 * Result of decryption operation
 */
export type DecryptionResult = { extracted_files: string[]; output_dir: string; manifest_verified: boolean; external_manifest_restored?: boolean | null }
/**
 * Input for deleting a vault
 */
export type DeleteVaultRequest = { vault_id: string; force: boolean }
/**
 * Response from vault deletion
 */
export type DeleteVaultResponse = { success: boolean; message: string }
/**
 * Input for encryption command
 */
export type EncryptDataInput = { key_id: string; file_paths: string[]; output_name: string | null; output_path: string | null }
/**
 * Encryption operation status
 */
export type EncryptionStatus = "Pending" | "InProgress" | "Completed" | "Failed" | "Cancelled"
/**
 * Response from encryption status command
 */
export type EncryptionStatusResponse = { operation_id: string; status: EncryptionStatus; progress_percentage: number; current_file: string | null; total_files: number; processed_files: number; total_size: number; processed_size: number; estimated_time_remaining: number | null; error_message: string | null }
/**
 * Error codes for client-side handling and internationalization
 * 
 * These codes enable the frontend to:
 * - Display appropriate error messages
 * - Implement error-specific recovery flows
 * - Provide localized error messages
 * - Handle errors programmatically
 * 
 * # TypeScript Equivalent
 * ```typescript
 * enum ErrorCode {
 * // Validation errors
 * INVALID_INPUT = 'INVALID_INPUT',
 * MISSING_PARAMETER = 'MISSING_PARAMETER',
 * // ... etc
 * }
 * ```
 */
export type ErrorCode = "INVALID_INPUT" | "MISSING_PARAMETER" | "INVALID_PATH" | "INVALID_KEY_LABEL" | "WEAK_PASSPHRASE" | "INVALID_FILE_FORMAT" | "FILE_TOO_LARGE" | "TOO_MANY_FILES" | "PERMISSION_DENIED" | "PATH_NOT_ALLOWED" | "INSUFFICIENT_PERMISSIONS" | "READ_ONLY_FILE_SYSTEM" | "KEY_NOT_FOUND" | "FILE_NOT_FOUND" | "DIRECTORY_NOT_FOUND" | "OPERATION_NOT_FOUND" | "ENCRYPTION_FAILED" | "DECRYPTION_FAILED" | "STORAGE_FAILED" | "ARCHIVE_CORRUPTED" | "MANIFEST_INVALID" | "INTEGRITY_CHECK_FAILED" | "CONCURRENT_OPERATION" | "DISK_SPACE_INSUFFICIENT" | "MEMORY_INSUFFICIENT" | "FILE_SYSTEM_ERROR" | "NETWORK_ERROR" | "INVALID_KEY" | "WRONG_PASSPHRASE" | "TAMPERED_DATA" | "UNAUTHORIZED_ACCESS" | "YUBI_KEY_ERROR" | "YUBI_KEY_NOT_FOUND" | "YUBI_KEY_PIN_REQUIRED" | "YUBI_KEY_PIN_BLOCKED" | "YUBI_KEY_TOUCH_REQUIRED" | "YUBI_KEY_TOUCH_TIMEOUT" | "WRONG_YUBI_KEY" | "YUBI_KEY_SLOT_IN_USE" | "YUBI_KEY_INITIALIZATION_FAILED" | "YUBI_KEY_COMMUNICATION_ERROR" | "VAULT_NOT_FOUND" | "VAULT_ALREADY_EXISTS" | "VAULT_KEY_LIMIT_EXCEEDED" | "PLUGIN_NOT_FOUND" | "PLUGIN_VERSION_MISMATCH" | "PLUGIN_EXECUTION_FAILED" | "PLUGIN_DEPLOYMENT_FAILED" | "NO_UNLOCK_METHOD_AVAILABLE" | "RECIPIENT_MISMATCH" | "MULTI_RECIPIENT_SETUP_FAILED" | "INTERNAL_ERROR" | "UNEXPECTED_ERROR" | "CONFIGURATION_ERROR"
/**
 * File information
 */
export type FileInfo = { path: string; name: string; size: number; is_file: boolean; is_directory: boolean; file_count: number | null }
/**
 * File selection result
 */
export type FileSelection = { paths: string[]; total_size: number; file_count: number; selection_type: string }
/**
 * Input for key generation command
 */
export type GenerateKeyInput = { label: string; passphrase: string }
/**
 * Input for multi-recipient key generation command
 */
export type GenerateKeyMultiInput = { label: string; passphrase: string | null; protection_mode: ProtectionMode | null; yubikey_device_id: string | null; yubikey_info: YubiKeyInfo | null; yubikey_pin: string | null }
/**
 * Response from key generation
 */
export type GenerateKeyMultiResponse = { public_key: string; key_id: string; saved_path: string; protection_mode: ProtectionMode; recipients: string[] }
/**
 * Response from key generation
 */
export type GenerateKeyResponse = { public_key: string; key_id: string; saved_path: string }
/**
 * Response containing current vault
 */
export type GetCurrentVaultResponse = { vault: VaultSummary | null }
/**
 * Input for encryption status command
 */
export type GetEncryptionStatusInput = { operation_id: string }
/**
 * Input for progress status command
 */
export type GetProgressInput = { operation_id: string }
/**
 * Response from progress status command
 */
export type GetProgressResponse = { operation_id: string; progress: number; message: string; details: ProgressDetails | null; timestamp: string; estimated_time_remaining: number | null; is_complete: boolean }
/**
 * Input for getting vault keys
 */
export type GetVaultKeysRequest = { vault_id: string }
/**
 * Response containing vault keys
 */
export type GetVaultKeysResponse = { vault_id: string; keys: KeyReference[] }
/**
 * Key metadata for frontend display
 */
export type KeyMetadata = { label: string; created_at: string; public_key: string | null }
/**
 * Reference to a key that can unlock a vault
 */
export type KeyReference = 
/**
 * Type of key
 */
(
/**
 * Passphrase-based key
 */
{ type: "passphrase"; key_id: string } | 
/**
 * YubiKey hardware token
 */
{ type: "yubikey"; serial: string; slot_index: number; piv_slot: number }) & { 
/**
 * Unique identifier for this key reference
 */
id: string; 
/**
 * User-friendly label
 */
label: string; 
/**
 * Current state of the key
 */
state: KeyState; 
/**
 * When this key was added to the vault
 */
created_at: string; 
/**
 * Last time this key was used
 */
last_used: string | null }
/**
 * State of a key in relation to the vault
 */
export type KeyState = 
/**
 * Key is available and can be used
 */
"active" | 
/**
 * Key is registered but not currently available (e.g., YubiKey not inserted)
 */
"registered" | 
/**
 * Key exists but is not associated with any vault
 */
"orphaned"
/**
 * Response containing list of vaults
 */
export type ListVaultsResponse = { vaults: VaultSummary[] }
/**
 * Manifest for encrypted archives
 */
export type Manifest = { version: string; created_at: string; files: FileInfo[]; total_size: number; file_count: number }
/**
 * Passphrase strength levels
 */
export type PassphraseStrength = "weak" | "fair" | "good" | "strong"
/**
 * Passphrase validation result
 */
export type PassphraseValidationResult = { is_valid: boolean; strength: PassphraseStrength; feedback: string[]; score: number }
/**
 * PIN policy for PIV operations
 */
export type PinPolicy = "Never" | "Once" | "Always"
/**
 * PIN status
 */
export type PinStatus = "default" | "set"
/**
 * PIN validation result
 */
export type PinValidationResult = { valid: boolean; message: string; requirements: string[] }
/**
 * Operation-specific progress details for different command types
 * 
 * This enum provides detailed progress information specific to different operation types.
 * The frontend can use this to display operation-specific progress indicators.
 * 
 * # TypeScript Equivalent
 * ```typescript
 * type ProgressDetails =
 * | { type: 'FileOperation'; current_file: string; total_files: number; current_file_progress: number; current_file_size: number; total_size: number }
 * | { type: 'Encryption'; bytes_processed: number; total_bytes: number; encryption_rate?: number }
 * | { type: 'Decryption'; bytes_processed: number; total_bytes: number; decryption_rate?: number }
 * | { type: 'ArchiveOperation'; files_processed: number; total_files: number; bytes_processed: number; total_bytes: number; compression_ratio?: number }
 * | { type: 'ManifestOperation'; files_verified: number; total_files: number; current_file: string };
 * ```
 */
export type ProgressDetails = 
/**
 * File operation progress (copying, moving, etc.)
 */
{ type: "FileOperation"; current_file: string; total_files: number; current_file_progress: number; current_file_size: number; total_size: number } | 
/**
 * Encryption operation progress
 */
{ type: "Encryption"; bytes_processed: number; total_bytes: number; encryption_rate: number | null } | 
/**
 * Decryption operation progress
 */
{ type: "Decryption"; bytes_processed: number; total_bytes: number; decryption_rate: number | null } | 
/**
 * Archive operation progress (compression, extraction)
 */
{ type: "ArchiveOperation"; files_processed: number; total_files: number; bytes_processed: number; total_bytes: number; compression_ratio: number | null } | 
/**
 * Manifest operation progress (verification, generation)
 */
{ type: "ManifestOperation"; files_verified: number; total_files: number; current_file: string } | 
/**
 * YubiKey operation progress
 */
{ type: "YubiKeyOperation"; operation: YubiKeyOperationType; phase: YubiKeyPhase; requires_interaction: boolean; context: string | null }
/**
 * Protection modes for vault security
 */
export type ProtectionMode = "PassphraseOnly" | { YubiKeyOnly: { serial: string } } | { Hybrid: { yubikey_serial: string } }
/**
 * YubiKey registration parameters for vault
 */
export type RegisterYubiKeyForVaultParams = { serial: string; pin: string; label: string; vault_id: string; slot_index: number }
/**
 * Result from YubiKey registration
 */
export type RegisterYubiKeyResult = { success: boolean; key_reference: KeyReference }
/**
 * Input for removing key from vault
 */
export type RemoveKeyFromVaultRequest = { vault_id: string; key_id: string }
/**
 * Response from removing key
 */
export type RemoveKeyFromVaultResponse = { success: boolean }
/**
 * File selection type
 */
export type SelectionType = "Files" | "Folder"
/**
 * Input for setting current vault
 */
export type SetCurrentVaultRequest = { vault_id: string }
/**
 * Response from setting current vault
 */
export type SetCurrentVaultResponse = { success: boolean; vault: VaultSummary }
/**
 * YubiKey initialization result for streamlined API
 */
export type StreamlinedYubiKeyInitResult = { serial: string; slot: number; recipient: string; identity_tag: string; label: string; recovery_code: string }
/**
 * Touch policy for PIV operations
 */
export type TouchPolicy = "Never" | "Always" | "Cached"
/**
 * Credentials for unlocking vaults
 */
export type UnlockCredentials = { Passphrase: { key_label: string; passphrase: string } } | { YubiKey: { serial: string; pin: string | null } }
/**
 * Unlock methods available for decryption
 */
export type UnlockMethod = "Passphrase" | "YubiKey"
/**
 * Input for updating key label
 */
export type UpdateKeyLabelRequest = { vault_id: string; key_id: string; new_label: string }
/**
 * Response from updating key label
 */
export type UpdateKeyLabelResponse = { success: boolean }
/**
 * Input for passphrase validation command
 */
export type ValidatePassphraseInput = { passphrase: string }
/**
 * Response from passphrase validation
 */
export type ValidatePassphraseResponse = { is_valid: boolean; message: string }
/**
 * Result of vault decryption operation
 */
export type VaultDecryptionResult = { method_used: UnlockMethod; recipient_used: string; files_extracted: string[]; output_path: string; decryption_time: string }
/**
 * Summary information about a vault (for listing)
 */
export type VaultSummary = { id: string; name: string; description: string | null; created_at: string; key_count: number }
/**
 * Input for key-passphrase verification command
 */
export type VerifyKeyPassphraseInput = { key_id: string; passphrase: string }
/**
 * Response from key-passphrase verification
 */
export type VerifyKeyPassphraseResponse = { is_valid: boolean; message: string }
/**
 * Input for manifest verification command
 */
export type VerifyManifestInput = { manifest_path: string; extracted_files_dir: string }
/**
 * Response from manifest verification command
 */
export type VerifyManifestResponse = { is_valid: boolean; message: string; file_count: number; total_size: number }
/**
 * Status of YubiKey connection test
 */
export type YubiKeyConnectionStatus = "Success" | { Failed: { reason: string } }
/**
 * Result of YubiKey connection test
 */
export type YubiKeyConnectionTest = { serial: string; status: YubiKeyConnectionStatus; tested_at: string }
/**
 * Frontend-compatible YubiKey device information
 * This structure matches the TypeScript interface expected by the frontend
 */
export type YubiKeyDevice = { device_id: string; name: string; serial_number: string | null; firmware_version: string | null; has_piv: boolean; has_oath: boolean; has_fido: boolean }
/**
 * YubiKey information after initialization
 */
export type YubiKeyInfo = { serial: string; slot: number; public_key: string; pin_policy: PinPolicy; touch_policy: TouchPolicy; label: string }
/**
 * YubiKey initialization parameters for vault
 */
export type YubiKeyInitForVaultParams = { serial: string; pin: string; label: string; vault_id: string; slot_index: number }
/**
 * YubiKey initialization result
 */
export type YubiKeyInitResult = { public_key: string; slot: number; touch_required: boolean; pin_policy: PinPolicy }
/**
 * Types of YubiKey operations
 */
export type YubiKeyOperationType = "Detection" | "Initialization" | "Authentication" | "KeyGeneration" | "Encryption" | "Decryption" | "PluginDeployment"
/**
 * Phases of YubiKey operations
 */
export type YubiKeyPhase = "Starting" | { InProgress: { percentage: number | null } } | "WaitingForPin" | "WaitingForTouch" | "Completing" | "Completed" | { Failed: { error: string } }
/**
 * YubiKey setup recommendations
 */
export type YubiKeySetupRecommendations = { serial: string; model: string; recommended_slot: number | null; available_slots: number[]; security_recommendations: string[]; compatibility_notes: string[] }
/**
 * YubiKey setup status
 */
export type YubiKeySetupStatus = { NeedsInitialization: { available_slots: number } } | { AlreadySetup: { note: string } }
/**
 * YubiKey state classification
 */
export type YubiKeyState = "new" | "reused" | "registered" | "orphaned"
/**
 * YubiKey state information
 */
export type YubiKeyStateInfo = { serial: string; state: YubiKeyState; slot: number | null; recipient: string | null; identity_tag: string | null; label: string | null; pin_status: PinStatus }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
